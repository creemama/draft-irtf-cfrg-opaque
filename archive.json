{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-01-05T01:07:01.291823+00:00",
  "repo": "cfrg/draft-irtf-cfrg-opaque",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWU2MjAyNDU1MjQ=",
      "title": "Drop TLS integration details",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/2",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should reference and rely on [1] when it's updated.\r\n\r\n[1] https://tools.ietf.org/html/draft-sullivan-tls-opaque-00",
      "createdAt": "2020-05-18T14:15:17Z",
      "updatedAt": "2020-06-19T15:14:46Z",
      "closedAt": "2020-06-19T15:14:46Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU2MjAyNDg5NTU=",
      "title": "Move security property discussion to considerations section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/3",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This will shorten the introduction and help readers get straight to the protocol details. HPKE does a good job with this sort of structure, so we might look there as a guide.",
      "createdAt": "2020-05-18T14:19:28Z",
      "updatedAt": "2020-10-28T13:03:22Z",
      "closedAt": "2020-10-28T13:03:22Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This has since been done.",
          "createdAt": "2020-10-28T13:03:22Z",
          "updatedAt": "2020-10-28T13:03:22Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU2MjAyNDkzNDk=",
      "title": "Clarify server trust",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/4",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Should we clarify how much trust we place in the server? For example, since OPAQUE stores encrypted keys in the server, and that same server has the OPRF secret key, it could in theory do a dictionary attack and recover the private key for each user. This is pretty nonsensical, but I think it does highlight that OPAQUE assumes the server is honest-but-curious, rather than entirely malicious.\r\n\r\nThis is sort of fundamental, but some folks might miss it.",
      "createdAt": "2020-05-18T14:19:58Z",
      "updatedAt": "2020-12-21T16:45:52Z",
      "closedAt": "2020-12-21T16:45:51Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is already discussed in the \"Password salt and storage implications\" section. Closing.",
          "createdAt": "2020-12-21T16:45:51Z",
          "updatedAt": "2020-12-21T16:45:51Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU2MjAyNTQwMzM=",
      "title": "Reconsider \"cost\" details section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/5",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The \"cost\" details are written assuming a traditional DH-based KE protocol. Should we try to generalize this, e.g., to cover KEM-based protocols? Moreover, the cost details might not age well as TLS 1.3 develops and possibly moves away from signatures, via, e.g., semi-static DH. Or we might just remove this section entirely. ",
      "createdAt": "2020-05-18T14:25:57Z",
      "updatedAt": "2020-11-02T22:18:22Z",
      "closedAt": "2020-11-02T22:18:22Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU2MjAyNTQ0MDA=",
      "title": "Add wire format details for registration and login flow messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/6",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "TLS notation would be easiest, given its ubiquity. ",
      "createdAt": "2020-05-18T14:26:28Z",
      "updatedAt": "2020-06-04T23:18:09Z",
      "closedAt": "2020-06-04T23:18:09Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU2MjAyNTQ5NTM=",
      "title": "Highlight the importance of IdU and IdS in the envelope and post-OPRF AKE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/7",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Endpoints MUST agree on these identities (and use the right values!) for security. ",
      "createdAt": "2020-05-18T14:27:09Z",
      "updatedAt": "2020-12-17T01:58:59Z",
      "closedAt": "2020-12-17T01:58:59Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is pretty much covered now. Closing.",
          "createdAt": "2020-12-17T01:58:59Z",
          "updatedAt": "2020-12-17T01:58:59Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU2MjA1ODA5MTM=",
      "title": "Typo in 3DH key derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/8",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The key K3dh needs to computed by the server as\r\n K3dh = ePubU^ePrivS | ePubU^PrivS | PubU^ePrivS\r\nThe current draft inverts the order between the last two elements making it inconsistent with the way the client computes the key.\r\n(Reported by Kevin Lewi)",
      "createdAt": "2020-05-19T00:09:37Z",
      "updatedAt": "2020-05-19T22:17:38Z",
      "closedAt": "2020-05-19T16:43:28Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "As you see my github skills improved significantly, but the truth I did\nthese postings guided by someone else :-)\n\nCan I  address pull requests directly? DO you need to define me as\ncontributor? Or is it better that I let you push changes?\n\n\n-- Hugo\n\nHelp build a *worldwide repository* of COVID-19 data\n<https://iReport.algorand.org>, open to all, everywhere.\n\n\nOn Tue, May 19, 2020 at 12:43 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> Closed #8 <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/8> via\n> #10 <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/10>.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/8#event-3352769127>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXXKFQIYX44QTCJJHK3RSKZL7ANCNFSM4NEQVXEQ>\n> .\n>\n",
          "createdAt": "2020-05-19T19:50:30Z",
          "updatedAt": "2020-05-19T19:50:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I forgot to add you as a contributor! Oops. Let me do that now.",
          "createdAt": "2020-05-19T19:58:52Z",
          "updatedAt": "2020-05-19T19:58:52Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. Also, add yourself as an author.\n\n-- Hugo\n\nHelp build a *worldwide repository* of COVID-19 data\n<https://iReport.algorand.org>, open to all, everywhere.\n\n\nOn Tue, May 19, 2020 at 3:59 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> Ah, I forgot to add you as a contributor! Oops. Let me do that now.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/8#issuecomment-631049168>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXTP7PCTIP7DRVPILW3RSLQIVANCNFSM4NEQVXEQ>\n> .\n>\n",
          "createdAt": "2020-05-19T22:17:37Z",
          "updatedAt": "2020-05-19T22:17:37Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU2MjA1OTMzNjk=",
      "title": "typos/comments from Eric Crockett",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/9",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Page 4, second paragraph: \u201cOKI-free\u201d -> \u201cPKI-free\u201d\r\n\r\nIn that same paragraph \"it works for RSA\" should be replaced with a better explanation. The point is that  SRP requires a ring: it mixes additions and multiplications. It does not work over plain elliptic curves.\r\n\r\nPage 8, section 2.1. DH-OPEF -> DH-OPRF",
      "createdAt": "2020-05-19T00:47:29Z",
      "updatedAt": "2020-05-21T21:27:52Z",
      "closedAt": "2020-05-21T21:27:52Z",
      "comments": []
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU2MjI2ODU4NDg=",
      "title": "Add OPRF domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/15",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The DST might include the \"RFCXXXX\" identifier, similar to what we did for HPKE.",
      "createdAt": "2020-05-21T18:16:49Z",
      "updatedAt": "2020-12-21T20:55:28Z",
      "closedAt": "2020-12-21T20:55:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We now include \"OPAQUEXX\" in `Finalize`. Closing.",
          "createdAt": "2020-12-21T20:55:27Z",
          "updatedAt": "2020-12-21T20:55:27Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU2MjI4NDM5NjI=",
      "title": "Specify profiles or configurations for servers",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/16",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This might include, for example, what sort of OPRF ciphersuite(s) are used. Or we might just say that this is decided out of band.",
      "createdAt": "2020-05-21T23:10:15Z",
      "updatedAt": "2020-05-28T16:17:15Z",
      "closedAt": "2020-05-28T16:17:15Z",
      "comments": []
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU2MjQ1Njk4MjM=",
      "title": "HMQV key derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/18",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The following changes the HMQV key derivation to include the session identifier (essentially what the value info is) under the key calculation (the changes are in the last 4 lines below)\r\n\r\nValues IKM and info are defined for each protocol:\r\n\r\nFor HMQV:\r\n\r\n - info = \"HMQV keys\" \\| nonceU \\| nonceS \\| IdU \\| IdS\r\n\r\n - IKM = Khmqv\r\n\r\n   where Khmqv is computed:\r\n\r\n   - by the client:  Khmqv = (ePubS \\* PubS^s)^{ePrivU + u\\*PrivU}\r\n\r\n   - by the server:  Khmqv = (ePubU \\* PubU^u)^{ePrivS + s\\*PrivS}\r\n\r\n   and u = H(ePubU | \"user\" | info) and s = H(ePubS | \"srvr\" | info).\r\n\r\n<!--     (u and s are often denoted d and e, respectively, in HMQV)   -->\r\n\r\nAlso, in subsection \"Instantiation of OPAQUE with HMQV and 3DH\", before the KEY DERIVATION heading, add the following note:\r\n\r\n   [[TODO: Specify that in the login phase, ephemeral DH values need to be\r\n   verified to belong to the correct group (via membership tests or cofactor\r\n   exponentiation). Same for public keys during the registration phase.\r\n   Details of verification depend on the particular group/curve. (What's done in\r\n   TLS 1.3?)]]\r\n\r\n",
      "createdAt": "2020-05-26T03:02:31Z",
      "updatedAt": "2020-05-29T15:08:35Z",
      "closedAt": "2020-05-29T15:08:35Z",
      "comments": []
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU2MjY0NjQyNDM=",
      "title": "Add common configurations for OPAQUE ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/19",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This basically specifies different configurations, where each configuration identifies the OPRF, RKR-AEAD, and MHF algorithm. For example, one configuration might be DH-OPRF with OPRF-curve448-HKDF-SHA512-ELL2-RO, CTR+HMAC with AES-256 and HMAC-SHA256, and scrypt (with reasonable parameters).",
      "createdAt": "2020-05-28T12:19:47Z",
      "updatedAt": "2020-08-30T16:20:39Z",
      "closedAt": "2020-08-30T16:20:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "These configurations should also specify values for the nonce, authentication key, and exporter key lengths.",
          "createdAt": "2020-06-17T17:14:12Z",
          "updatedAt": "2020-06-17T17:14:12Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU2MjY0NjUxNzI=",
      "title": "Should all Credential fields be encrypted?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/20",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some fields, like the user public key, might only require authentication.",
      "createdAt": "2020-05-28T12:21:21Z",
      "updatedAt": "2020-06-18T23:36:20Z",
      "closedAt": "2020-06-18T23:36:20Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Authenticating-only the server's public key can be beneficial in a setting where the server uses the same public key with multiple clients. Encrypting the key means a larger envelope stored as *each*  user's record while authenticating-only makes both the envelope and per-user shorter shorter. There is some savings in not having to decrypt the server's public key but this seems negligible (especially if the authentication operation that cannot be avoided is more expensive than decryption).",
          "createdAt": "2020-06-02T16:31:07Z",
          "updatedAt": "2020-06-02T16:31:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was resolved in #36.",
          "createdAt": "2020-06-18T23:36:20Z",
          "updatedAt": "2020-06-18T23:36:20Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU2MjY0NjcwODU=",
      "title": "Move KdKey derivation to the Seal/Open calling code",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/21",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This key is used for applications that choose to process user information beyond the OPAQUE functionality (e.g., additional secrets or credentials).",
      "createdAt": "2020-05-28T12:24:30Z",
      "updatedAt": "2020-06-17T17:13:39Z",
      "closedAt": "2020-06-17T17:13:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is now done.",
          "createdAt": "2020-06-17T17:13:39Z",
          "updatedAt": "2020-06-17T17:13:39Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU2MjY0NzAwNjk=",
      "title": "Lift user enumeration text to the OPAQUE AKE stage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/22",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We might consider standardizing the mechanism by which servers prevent user enumeration attacks. ",
      "createdAt": "2020-05-28T12:29:17Z",
      "updatedAt": "2020-08-24T17:32:34Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU2MjY3MjY4Nzc=",
      "title": "Derive fresh nonces at envelope creation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/23",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The nonce used in envelope encryption should not be derived from RwdU but rather chosen freshly at random at the time of encryption (envelope creation) and be stored (and sent) as part of the envelope. This avoids reusing the same encryption stream for encrypting two different plaintexts.",
      "createdAt": "2020-05-28T18:38:50Z",
      "updatedAt": "2020-05-29T12:45:59Z",
      "closedAt": "2020-05-29T12:45:58Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #24.",
          "createdAt": "2020-05-29T12:45:58Z",
          "updatedAt": "2020-05-29T12:45:58Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU2MjY3Nzk1OTk=",
      "title": "Investigate OPRF generality",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/25",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We currently rely on a GenerateScalar function from the OPRF, which might not be a thing for OPRFs that are not based on Diffie-Hellman. We should consider how we might generalize this here, or perhaps in the OPRF document itself.",
      "createdAt": "2020-05-28T20:05:40Z",
      "updatedAt": "2020-09-19T12:04:44Z",
      "closedAt": "2020-09-19T12:04:44Z",
      "comments": []
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU2MjcyNDk1NDI=",
      "title": "Private key encodings",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/26",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We might use PKCS#8 as an encoding for credential private keys, or we might use language that suggests this is specific to each instantiation. ",
      "createdAt": "2020-05-29T12:56:46Z",
      "updatedAt": "2020-06-17T17:13:28Z",
      "closedAt": "2020-06-17T17:13:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as an application/instantiation-specific concern.",
          "createdAt": "2020-06-17T17:13:27Z",
          "updatedAt": "2020-06-17T17:13:27Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU2MjcyNTE5Mzk=",
      "title": "Validate ephemeral key shares",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/27",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Specify that in the login phase, ephemeral DH values need to be verified to belong to the correct group (via membership tests or cofactor exponentiation). Same holds for public keys during the registration phase. Details of verification depend on the particular group/curve.",
      "createdAt": "2020-05-29T13:00:47Z",
      "updatedAt": "2020-08-30T16:26:04Z",
      "closedAt": "2020-08-30T16:26:04Z",
      "comments": []
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU2MjkzNTcyMzI=",
      "title": "Using HKDF-Expand in deriving KEYS",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/29",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Instead of  KEYS = HKDF(salt=0, IKM=k, info=\"EnvU\", Length=L1+L2+L3) one could do \r\nKEYS = HKDF-Expand(key=k, info=\"EnvU\", Length=L1+L2+L3)\r\nwhich makes more sense since k is already a pseudo random key, we would only need to specify that k is the length of an HMAC key.",
      "createdAt": "2020-06-02T16:50:34Z",
      "updatedAt": "2020-06-18T23:36:09Z",
      "closedAt": "2020-06-18T23:36:09Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is done in #36.",
          "createdAt": "2020-06-17T17:13:07Z",
          "updatedAt": "2020-06-17T17:13:07Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU2MjkzNjM5MTU=",
      "title": "KdKey rationale ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/30",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need to add the rationale for KdKey somewhere. Can use the following as a basis:\r\n\r\nThe main use case I have in mind is retrieving a non-OPAQUE encrypted credential. Namely, expanding the use of OPAQUE with a credential-retrieval functionality. You could always put additional stuff in the envelope but I would prefer to restrict the envelope with its OPAQUE-specific functionality. In addition, having a separate encrypted credential can achieve several properties: allowing the server to send it only after the user authenticated; send it under the session key with forward secrecy; allowing the addition of a credential to the user's record after registration; allowing the use of non-RKR encryption for credential encryption; and just giving better extensibility, flexibility and separation from the core OPAQUE protocol.",
      "createdAt": "2020-06-02T17:01:06Z",
      "updatedAt": "2020-08-31T14:25:21Z",
      "closedAt": "2020-08-31T14:25:21Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is sort of like the TLS exporter secret. I'll see if I can write it as such!",
          "createdAt": "2020-06-04T20:58:08Z",
          "updatedAt": "2020-06-04T20:58:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw do you think the current rationale is sufficient? If not, would you mind proposing text to improve (expand) it?",
          "createdAt": "2020-07-21T16:44:26Z",
          "updatedAt": "2020-07-21T16:44:26Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I assume you mean the text under {export-usage}.\r\nI think it is ok.\r\nIt may be a good idea to add the following (which I have in my draft):\r\nThere is no restriction for the type of encryption scheme\r\n   used in this case.  However, ExportKey MUST NOT be used in any way\r\n   before the HMAC value in EnvU is validated. ",
          "createdAt": "2020-07-21T19:53:00Z",
          "updatedAt": "2020-07-21T19:53:00Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU2Mjk0MjQ1OTg=",
      "title": "On including pkU in the envelope",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/31",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add a note: pkU is often not needed by the client to run the key exchange stage in which case it can be omitted from the envelope and not sent from server to client in the online stage. In particular, this is the case for the three instantiations here: 3DH, HMQV and SIGMA.",
      "createdAt": "2020-06-02T18:34:04Z",
      "updatedAt": "2020-06-18T23:36:02Z",
      "closedAt": "2020-06-18T23:36:02Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed in #36.",
          "createdAt": "2020-06-18T23:36:02Z",
          "updatedAt": "2020-06-18T23:36:02Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU2NDA4Njc5NzA=",
      "title": "Clarify KDF(Expand) and MAC requirements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/37",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Future implementers may wish to replace HKDF-Expand and HMAC with their own (read:faster?) variants, so we should make clear the rationale for using these. Per the analysis, we require random-key robustness from HMAC, which is not something all MACs provide. (GMAC and poly1305 don't, for example.) HKDF-Expand could possibly be replaced by a different variable-length output PRF.",
      "createdAt": "2020-06-18T02:56:35Z",
      "updatedAt": "2020-08-30T16:20:23Z",
      "closedAt": "2020-08-30T16:20:23Z",
      "comments": []
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU2NjAyMjQyMjU=",
      "title": "Typo: nonce appears twice",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/42",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In line\r\nexport_key = HKDF-Expand(RwdU, concat(nonce, \"ExportKey\", nonce), Nk)\r\nnonce appears twice",
      "createdAt": "2020-07-18T15:53:08Z",
      "updatedAt": "2020-07-21T16:43:49Z",
      "closedAt": "2020-07-21T16:43:49Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice catch! I fixed this directly on master.",
          "createdAt": "2020-07-21T16:43:38Z",
          "updatedAt": "2020-07-21T16:43:38Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU2NjAyMzUxMTg=",
      "title": "lengths of elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/43",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Who, when and how determines  the length of elements to be generated or received. For example, how does the client know what the value of Nk should be. More significant how does the client know Nk or len(pt) when receiving the envelope?\r\n\r\nOn a related note, for a derivation like\r\nSK, Km2, Km3, Ke2, Ke3 = HKDF(salt=0, IKM, info, L)\r\nwe need to assume that the client knows how to parse the key stream correctly and uniquely hence it needs to know the lengths of each key.  This is also needed even if we compute a separate HKDF-Expand for each value (since Expand requires to define a length value). How does the client know these values, are these determined by the specific algorithms or ciphersuite ? Should this information be part of the information authenticated by the envelope or some other mechanism?\r\nHow does TLS 1.3 deals with this, namely, how it communicates and authenticates the ciphersuite/algorithms/version?",
      "createdAt": "2020-07-18T16:13:01Z",
      "updatedAt": "2020-08-30T16:22:47Z",
      "closedAt": "2020-08-30T16:22:47Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Who, when and how determines the length of elements to be generated or received. For example, how does the client know what the value of Nk should be. \r\n\r\nThis is part of the configuration. We should define this!\r\n\r\n> More significant how does the client know Nk or len(pt) when receiving the envelope?\r\n\r\nThe length of the envelope's ciphertext is equal to len(pt), so the client uses that to determine the length of the pad.\r\n\r\nOn the length of keys, they're all `Nk` bytes long, which is part of the configuration. I'll throw up a PR that defines this. Unlike TLS, I don't think we want to negotiate the ciphersuite in-band (in the core protocol spec -- we might do something differently for the instantiations).",
          "createdAt": "2020-07-21T16:48:55Z",
          "updatedAt": "2020-07-21T17:10:39Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The ciphersuite needs to be set and fixed at registration time and it needs to be learned by the client during login.  If this information is wired into the client implementation/configuration then no need to worry about it. But otherwise, we need care (e.g., if the client is a browser contacting a server for which the client does not have configuration information).\r\nThe OPRF needs to be known or guessed before getting the envelope (similar to key_share algorithms in TLS 1.3). Do we need to have a mechanism for the server to say, please use this other OPRF if the guess was incorrect? Should we worry about downgrade attacks?\r\nFor the envelope the client needs to know what hash to use (how does it learn that?). If the OPRF and hash used by the client are correct, then we can trust the MAC computed on the envelope to detect any manipulation of the envelope. \r\nAnd then there is the AKE ciphersuite that needs to include the AKE protocol type itself (SIGMA, 3DH, etc)  and the specific algorithms/curves used by the AKE implementation. But the latter can be encoded into the envelope itself and verified by the MAC.",
          "createdAt": "2020-07-21T21:20:10Z",
          "updatedAt": "2020-07-21T21:20:10Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "How does the client parse/differentiate ciphertext and auth_data? I assume this is defined by the Envelope struct, but I don't know how these things are implemented. DO they have special separators, length values, etc.? I am worried about possible attacks that play with the boundaries of these elements.",
          "createdAt": "2020-07-22T16:14:13Z",
          "updatedAt": "2020-07-22T16:14:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> How does the client parse/differentiate ciphertext and auth_data? I assume this is defined by the Envelope struct, but I don't know how these things are implemented. DO they have special separators, length values, etc.? I am worried about possible attacks that play with the boundaries of these elements.\r\n\r\nIndeed! Clients know to parse the ciphertext and auth_data in sequence (by the struct's definition), and know how to parse the type and length of each element in these lists. Everything should be unambiguous.",
          "createdAt": "2020-08-30T16:22:45Z",
          "updatedAt": "2020-08-30T16:22:45Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWU2OTA0ODk5NzQ=",
      "title": "parsing of envelope when ct/pt are variable length",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/51",
      "state": "OPEN",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "At the end of the `#protocol-messages` section is a description of the envelope structure as seen here:\r\n\r\n```\r\nOPAQUE uses an `Envelope` structure to encapsulate an encrypted `Credentials` structure.\r\nIt is encoded as follows.\r\n\r\n~~~\r\nstruct {\r\n  opaque nonce[32];\r\n  opaque ct<1..2^16-1>;\r\n  opaque auth_data<0..2^16-1>;\r\n  opaque auth_tag<1..2^16-1>;\r\n} Envelope;\r\n~~~\r\n\r\nnonce\r\n: A unique 32-byte nonce used to protect this Envelope.\r\n\r\nct\r\n: Encoding of encrypted and authenticated credential extensions list.\r\n\r\nauth_data\r\n: Encoding of an authenticated credential extensions list.\r\n\r\nauth_tag\r\n: Authentication tag protecting the contents of the envelope.\r\n```\r\n\r\nas an implementer of opaque (see here https://github.com/stef/libsphinx/blob/master/src/opaque.c) i wonder how to parse this structure when both fields might be of variable length. In such a case it is useful to have the lengths included in the auth_data section at known offsets of the envelope. hence i propose to move the auth_data section infront of the ct section, either at the very beginning before the nonce, or between the nonce and the ct, in both cases an instantiation of the protocol can decide to include the lengths at known offsets and will be able to parse the envelope, even if this means that these lengths are used before they are authenticated.",
      "createdAt": "2020-09-01T22:25:34Z",
      "updatedAt": "2020-10-28T13:03:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "on another note the line `opaque auth_tag<1..2^16-1>; is confusing the rest of the document suggest that the `<>` enclosed parameter is length, however hmacs provide quite specific length tags.",
          "createdAt": "2020-09-02T00:21:05Z",
          "updatedAt": "2020-09-02T00:21:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> as an implementer of opaque (see here https://github.com/stef/libsphinx/blob/master/src/opaque.c) i wonder how to parse this structure when both fields might be of variable length. \r\n\r\nParsing these fields should be pretty straightforward. For example, consider `ct`, which is `opaque ct<1..2^16-1>`. To parse this, first parse a 2-byte length field, and then parse the remaining bytes (of that length) as the `ct` data. (This MUST be of length at least 1, which is what the `<1..2^16-1>` denotes.)\r\n\r\n> on another note the line opaque auth_tag<1..2^16-1>; is confusing the rest of the document suggest that the <>` enclosed parameter is length, however hmacs provide quite specific length tags.\r\n\r\nIt's true that the output of HMAC is fixed depending on the underlying hash function, but we chose to make this variable length in case clients wanted to truncate the tag to save space. (We can mark this as an open issue, because, as you hint, applications making such decisions isn't great.)",
          "createdAt": "2020-09-03T00:57:07Z",
          "updatedAt": "2020-09-03T00:57:07Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "> > as an implementer of opaque (see here https://github.com/stef/libsphinx/blob/master/src/opaque.c) i wonder how to parse this structure when both fields might be of variable length.\r\n> \r\n> Parsing these fields should be pretty straightforward. \r\n\r\nindeed it should ;)\r\n\r\n> For example, consider `ct`, which is `opaque ct<1..2^16-1>`. To parse this, first parse a 2-byte length field,\r\n\r\nmaybe i missed this, but where is this 2-byte length field defined for ct? if it is plaintext, shouldn't it be explicitly protected by they authentication of the envelope and thus belongs in the auth_data section? does that imply there are more cleartext parts in the envelope besides the explicitly listed auth_data section? is there also a length field somewhere defined for the auth_data section?\r\n\r\n> and then parse the remaining bytes (of that length) as the `ct` data. (This MUST be of length at least 1, which is what the `<1..2^16-1>` denotes.)\r\n> \r\n> > on another note the line opaque auth_tag<1..2^16-1>; is confusing the rest of the document suggest that the <>` enclosed parameter is length, however hmacs provide quite specific length tags.\r\n> \r\n> It's true that the output of HMAC is fixed depending on the underlying hash function, but we chose to make this variable length in case clients wanted to truncate the tag to save space. (We can mark this as an open issue, because, as you hint, applications making such decisions isn't great.)\r\n\r\ni think it makes sense to just write `<Nh>` and refer to #cryptographic-protocol-and-algorithm-dependencies",
          "createdAt": "2020-09-03T18:15:26Z",
          "updatedAt": "2020-09-03T18:15:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> maybe i missed this, but where is this 2-byte length field defined for ct? if it is plaintext, shouldn't it be explicitly protected by they authentication of the envelope and thus belongs in the auth_data section? does that imply there are more cleartext parts in the envelope besides the explicitly listed auth_data section? is there also a length field somewhere defined for the auth_data section?\r\n\r\nI think perhaps you're confused by the terminology. These variable-length fields are using standard TLS notation (https://tools.ietf.org/html/rfc8446#section-3.4). Quoting that document:\r\n\r\n> Variable-length vectors are defined by specifying a subrange of legal\r\n> lengths, inclusively, using the notation <floor..ceiling>.  When\r\n> these are encoded, the actual length precedes the vector's contents\r\n> in the byte stream.",
          "createdAt": "2020-09-03T20:01:29Z",
          "updatedAt": "2020-09-03T20:01:29Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "oh. maybe it makes sense to state this explicitly, it helps understanding this much easier for people that do not speak tls natively.",
          "createdAt": "2020-09-03T20:08:54Z",
          "updatedAt": "2020-09-03T20:08:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's stated here:\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#protocol-messages-protocol-messages\r\n\r\nWould an example section be more helpful? (I agree it's not obvious without that prior context!)",
          "createdAt": "2020-09-03T20:32:58Z",
          "updatedAt": "2020-09-03T20:32:58Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "yeah i noticed that, but i have not anticipated the implicit consequences of that. the notation that is below as examples looks kinda self-explaining - except for the parts that are not explicitly spelled out...\r\nmaybe  an example section would be more helpful, or alternatively an explicit spelled out part that explains what is not obvious from the defintions below.",
          "createdAt": "2020-09-03T20:35:40Z",
          "updatedAt": "2020-09-03T20:35:40Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "sorry , clicked on the wrong button.",
          "createdAt": "2020-09-03T20:35:55Z",
          "updatedAt": "2020-09-03T20:35:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "To help craft that section, could you please list the notation that you do find confusing? I can then try to clarify. ",
          "createdAt": "2020-09-03T20:37:34Z",
          "updatedAt": "2020-09-03T20:37:34Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "after reading section 3 of RFC8446, i'd say the length of the field being implicit in that notation should be definitely \r\nnoted, and what i also learned, that in the struct `opaque` is the \"type\" of the value and in no way related to the protocol being specified, that is also kinda confusing in retrospect. otherwise i think enums and structs do not have hidden semantics, and as far as i see variants are not used. so i guess that's then these two things lengths of arrays and the type `opaque` as a special mention that this is a type and a name collision only.",
          "createdAt": "2020-09-03T21:51:38Z",
          "updatedAt": "2020-09-03T21:51:38Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "uh, i see that variants are used in the ProtocolMessage struct.",
          "createdAt": "2020-09-04T13:11:31Z",
          "updatedAt": "2020-09-04T13:11:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> after reading section 3 of RFC8446, i'd say the length of the field being implicit in that notation should be definitely\r\nnoted, and what i also learned, that in the struct opaque is the \"type\" of the value and in no way related to the protocol being specified, that is also kinda confusing in retrospect. otherwise i think enums and structs do not have hidden semantics, and as far as i see variants are not used. so i guess that's then these two things lengths of arrays and the type opaque as a special mention that this is a type and a name collision only.\r\n\r\nOkay, thanks! I'll try to clarify these things.\r\n\r\n> uh, i see that variants are used in the ProtocolMessage struct.\r\n\r\nIs there a question hidden in here?\r\n",
          "createdAt": "2020-09-04T18:22:51Z",
          "updatedAt": "2020-09-04T18:22:51Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "> > uh, i see that variants are used in the ProtocolMessage struct.\r\n> \r\n> Is there a question hidden in here?\r\n\r\nwell yes, i first thought that variants are not used in the OPAQUE draft, only later i saw it, so the semantics of variants are quite understandable, but might also deserve mention in the clarifying section.\r\n",
          "createdAt": "2020-09-04T20:02:15Z",
          "updatedAt": "2020-09-04T20:02:15Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU2OTMxMzg0NDk=",
      "title": "rename Evaluate() to Contribute()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/53",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "since github does not support reviewing markdown documents i'm submitting this as an issue:\r\n\r\nThe OPRF primitive defines a \r\n```\r\nEvaluate(k, M): Evaluate input M using private key k.\r\n```\r\nfunction, semantically i think it makes more sense to call this function Contribute as this conveys better what is happening, Evaluate() is less specific to the purpose of what is happening here.",
      "createdAt": "2020-09-04T12:54:48Z",
      "updatedAt": "2020-09-19T12:03:52Z",
      "closedAt": "2020-09-19T12:03:51Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you elaborate on why `Contribute` is more clear? As written, I don't agree.",
          "createdAt": "2020-09-06T13:52:52Z",
          "updatedAt": "2020-09-06T13:52:52Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "because in an OPRF two parties collaborate to calculate a value `c^s`. The client (c) blinds his value `c` using the blinding factor `r`, then sends over this blinded value to the server, who contributes his value `s` to the computation and returns it to the client. the client then unblinds the value from the server getting as a result `c^s`. ",
          "createdAt": "2020-09-06T14:07:00Z",
          "updatedAt": "2020-09-06T14:07:00Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "on another note i would also rephrase \"using private key k\" to \"using secret key k\" as the usage of \"private\" suggest that there is also a public key associated with this, while there isn't. and as far as i can judge for this kind of usage it is more common to refer as secret and not private keys.",
          "createdAt": "2020-09-06T15:02:06Z",
          "updatedAt": "2020-09-06T15:02:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Use of \u201cprivate key\u201d matches terminology in the OPRF dependent document. Use of Evaluate is also a result of that document. I suggest filing an issue against that repository to consider Contribute.",
          "createdAt": "2020-09-06T20:20:10Z",
          "updatedAt": "2020-09-06T20:20:10Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "thanks will. do.",
          "createdAt": "2020-09-06T20:38:18Z",
          "updatedAt": "2020-09-06T20:38:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing based on the outcome of https://github.com/cfrg/draft-irtf-cfrg-voprf/issues/140.",
          "createdAt": "2020-09-19T12:03:51Z",
          "updatedAt": "2020-09-19T12:03:51Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWU2OTMxNDA0MjU=",
      "title": "What is an OPRF keypair?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/54",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in the Cryptographic primitives section there is this sentence:\r\n```\r\nWe also assume the existence of a function KeyGen, which generates an OPRF private and public key.\r\n```\r\ni'm sorry, but what does that mean? The notion of a keypair in the OPRF context makes no sense to me.",
      "createdAt": "2020-09-04T12:56:53Z",
      "updatedAt": "2020-09-16T13:34:41Z",
      "closedAt": "2020-09-16T13:34:41Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "i just realized this might be a typo and should say OPAQUE instead of OPRF?",
          "createdAt": "2020-09-04T13:06:00Z",
          "updatedAt": "2020-09-04T13:06:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not a typo. The OPRF dependency in this document has a private and public key component to it. (Is your point that it should only be a secret key?) ",
          "createdAt": "2020-09-06T13:54:17Z",
          "updatedAt": "2020-09-06T13:54:17Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "OPRF as such does not use any public/private keypair. An OPRF blinds the value of the initiator, the responder contributes its own value, and the initiator then unblinds the responders value. there is no use for a (sk=x, pk=g^x) keypair in this computation.",
          "createdAt": "2020-09-06T14:10:42Z",
          "updatedAt": "2020-09-06T14:10:42Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "however OPAQUE itself makes use of public private keypairs (and thus of keygen) for the values pkU, skU, pkS, skS, and their ephemeral counterparts. thus my assumption this being a typo.",
          "createdAt": "2020-09-06T14:12:30Z",
          "updatedAt": "2020-09-06T14:12:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Please review the dependent OPRF document. This OPRF has a public and private key pair. The public key is only used for verification, which is why OPAQUE discards it. ",
          "createdAt": "2020-09-06T20:18:17Z",
          "updatedAt": "2020-09-06T20:18:17Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "sorry, i only read the paper by Jarecki et al., i wasn't aware that there is also an IETF (V)OPRF rfc draft. looking at that it makes kind of sense to call this keygen(), as for nist curves it must be guaranteed that the scalar is member of the field. and for voprfs actually to verify it. thanks for pointing that out, maybe this could be explained where the keygen() is mentioned in the opaque draft",
          "createdAt": "2020-09-06T20:37:20Z",
          "updatedAt": "2020-09-06T20:48:12Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "i just reread the paper, and i apologize for the noise. ",
          "createdAt": "2020-09-16T13:34:41Z",
          "updatedAt": "2020-09-16T13:34:41Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWU2OTQzODU1MDg=",
      "title": "uint24 in ProtocolMessage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/55",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "`ProtocolMessage` defines the `length` field to be of type `uint24`, i understand this is to handle messages that are composed of a few max 2^16 long parts, and possibly to conserve bandwidth? is it possible to make this 32bit which is a native and widely used size instead of 24bits.",
      "createdAt": "2020-09-06T13:40:50Z",
      "updatedAt": "2020-09-06T14:15:08Z",
      "closedAt": "2020-09-06T14:15:08Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The full ProtocolMessage struct is as follows:\r\n\r\n~~~\r\nstruct {\r\n    ProtocolMessageType msg_type;    /* protocol message type */\r\n    uint24 length;                   /* remaining bytes in message */\r\n    select (ProtocolMessage.msg_type) {\r\n        case registration_request: RegistrationRequest;\r\n        case registration_response: RegistrationResponse;\r\n        case registration_upload: RegistrationUpload;\r\n        case credential_request: CredentialRequest;\r\n        case credential_response: CredentialResponse;\r\n    };\r\n} ProtocolMessage;\r\n~~~\r\n\r\nNote that `msg_type` is one byte, so one can skip over the type/length by 4 bytes if desired. `uint32` is fairly large for one of these messages, and `uint16` may be too small, so we went with `uint24` for alignment purposes.",
          "createdAt": "2020-09-06T13:52:17Z",
          "updatedAt": "2020-09-06T13:52:17Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "uint16 is definitely too small (since some parts of these messages can be more than 2*2^16-2 in size). using msg_type and length in one 32bit word makes sense though.",
          "createdAt": "2020-09-06T14:14:32Z",
          "updatedAt": "2020-09-06T14:14:32Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWU3MDQ4NzA5ODM=",
      "title": "Should the nonce length be a parameter?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/58",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's currently set 32 bytes, which may be too much (?) in some circumstances. However, adding yet another parameter that applications must choose is not great. ",
      "createdAt": "2020-09-19T12:10:05Z",
      "updatedAt": "2020-10-28T13:05:35Z",
      "closedAt": "2020-10-28T13:05:34Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it should be fine to keep this as 32 bytes, erroring on the side of safety without too much of a drawback.",
          "createdAt": "2020-10-21T22:42:38Z",
          "updatedAt": "2020-10-21T22:42:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I applied this directly on main. Closing.",
          "createdAt": "2020-10-28T13:05:34Z",
          "updatedAt": "2020-10-28T13:05:34Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWU3MDkyMTA3OTE=",
      "title": "SHA-256 for Curve25519-based OPRF ciphersuites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/59",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, SHA-512 is used for all OPRF suites, which is quite excessive. (This is more an issue against the OPRF draft, I'm but filing it here to track the change in our doc.)",
      "createdAt": "2020-09-25T18:56:57Z",
      "updatedAt": "2020-11-02T23:54:06Z",
      "closedAt": "2020-11-02T23:54:06Z",
      "comments": []
    },
    {
      "number": 60,
      "id": "MDU6SXNzdWU3MDkyMTEyOTc=",
      "title": "Consider adding a registry",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/60",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The configurations are rather loosely defined. A registry that allows one to encode an entire configuration (AKE, OPRF, MHF, etc) could be useful. ",
      "createdAt": "2020-09-25T18:57:48Z",
      "updatedAt": "2020-10-28T13:05:48Z",
      "closedAt": "2020-10-28T13:05:48Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Nevermind! Closing.",
          "createdAt": "2020-10-28T13:05:48Z",
          "updatedAt": "2020-10-28T13:05:48Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWU3MTQ0MTcyNjc=",
      "title": "Envelope format in registration versus login",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/62",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Should this line (https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L583) be similar to this line (https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L787)?\r\n\r\nEither both should read `Envelope envelope;`, or both should read `opaque envelope<1..2^16-1>`, right?",
      "createdAt": "2020-10-04T22:37:27Z",
      "updatedAt": "2020-10-20T00:47:44Z",
      "closedAt": "2020-10-20T00:47:44Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Doh, yes, that's an error. Let's make them both the former (`Envelope envelope`). Can you please submit a PR to correct this?",
          "createdAt": "2020-10-19T18:32:21Z",
          "updatedAt": "2020-10-19T18:32:21Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWU3MTQ0NTQ0NjY=",
      "title": "Extraneous parameter pkS in CredentialResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/63",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Why is it necessary to [put pkS in the CredentialResponse struct](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L788)?\r\n\r\nAccording to [this](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L460-L464), pkS must be included within the envelope already. So, when the client parses the CredentialResponse struct, shouldn't it be able to obtain pkS from the envelope already?",
      "createdAt": "2020-10-05T01:47:20Z",
      "updatedAt": "2020-12-30T04:20:11Z",
      "closedAt": "2020-10-26T21:45:05Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good question! I *think* it can probably be removed, but let's see what @hugokraw thinks?",
          "createdAt": "2020-10-19T18:31:10Z",
          "updatedAt": "2020-10-19T18:31:10Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I did not notice pkS is sent outside the envelope. Not only it would be redundant but pkS is the most important element to be authenticated as part of the envelope. Sending it outside may lead people to accept it without authentication.",
          "createdAt": "2020-10-19T22:23:30Z",
          "updatedAt": "2020-10-19T22:23:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's drop it. @kevinlewi, can you please prep a PR to do this?",
          "createdAt": "2020-10-21T22:35:57Z",
          "updatedAt": "2020-10-21T22:35:57Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "In light of the changes made in #102, this will need to be re-introduced again.",
          "createdAt": "2020-12-30T04:20:11Z",
          "updatedAt": "2020-12-30T04:20:11Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU3MjQ0MDY5ODk=",
      "title": "Omitting idU parameter in RegistrationRequest and CredentialRequest messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/65",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The idU parameter is not used by the server when receiving the `RegistrationRequest` and `CredentialRequest` messages from the client. Can this parameter be omitted from the specification of these messages?\r\n\r\nIn theory, the server does need some \"username\" equivalent in order to look up the client's record, so this information does need to be sent, but I don't think it should be included in the OPAQUE messages, since it has no function within OPAQUE other than to set/retrieve the appropriate password file.\r\n\r\nPresumably, any wrapper protocol which uses OPAQUE will not want to look into the bytes of the OPAQUE messages in order to figure out what the username is.",
      "createdAt": "2020-10-19T08:43:53Z",
      "updatedAt": "2020-10-28T18:59:13Z",
      "closedAt": "2020-10-28T18:59:13Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, it needs to be included in the transcript for the AKEs, I think, so that's why it's part of the `CredentialRequest` message. ",
          "createdAt": "2020-10-19T18:30:37Z",
          "updatedAt": "2020-10-19T18:30:37Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The presence of idU is dependent on the AKE protocol used, and so even though it may get sent over as the first message of the AKE, shouldn't this be controlled by the specification of the AKE, and not the OPRF component?\r\n\r\nAlso, this is only for `CredentialRequest`, since `RegistrationRequest` does not use idU. I would be happy with delegating the specifying of idU to the AKE component.",
          "createdAt": "2020-10-19T23:35:56Z",
          "updatedAt": "2020-10-19T23:35:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The presence of idU is dependent on the AKE protocol used, and so even though it may get sent over as the first message of the AKE, shouldn't this be controlled by the specification of the AKE, and not the OPRF component?\r\n\r\nThat's true. One thing I have in my implementation notes is whether we ought to include *both* `idU` and `pwdU` in the OPRF input, rather than just `pwdU`. Given that `kU` is unique per `idU`, this probably doesn't make a meaningful change in security, though I wonder if it's just cleaner aesthetically?\r\n\r\nI could go either way, I guess. I'm curious to hear what @hugokraw thinks.",
          "createdAt": "2020-10-20T00:04:25Z",
          "updatedAt": "2020-10-20T00:04:25Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  One thing I have in my implementation notes is whether we ought to include both idU and pwdU in the OPRF input, rather than just pwdU.\r\n\r\nThat is certainly a valid consideration, but regardless of whether or not this is changed, I believe we can still omit idU from the `RegistrationRequest` and `CredentialRequest` messages, since the server doesn't use them (except for in the AKE component potentially).",
          "createdAt": "2020-10-20T00:09:22Z",
          "updatedAt": "2020-10-20T00:09:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "True, though I wonder if that just complicates things. (I don't disagree with the proposal. I just need to think about it more.)",
          "createdAt": "2020-10-20T00:14:18Z",
          "updatedAt": "2020-10-20T00:14:18Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Kevin, as you say correctly some form of user identity needs to be sent to the server for fetching the user's record. I would actually think that this transmission of identity is very much a role of the password authentication protocol, namely, OPAQUE. I can also see that this information may be transmitted in some other way (e.g., a wrapper) but I would not want to rely 100% on that possibility. Can we make the idU in the CredentialRequest message optional? Would that address your concern? \r\nThe setting in which the RegistrationRequest message acts is more complex as there are many issues involved in this case, particularly ways for the server to validate it is talking to the claimed user. In that case there may be a more complex wrapper. But even then, it feels that a support for a minimal implementation that  communicated idU from client to server could be supported. But in issues of implementation and deployment I  let you guys have the last word.\r\n\r\nAs for including idU under the OPRF input, I am ok with it. I am in favor of analyzing minimalistic protocols to understand what's the minimum elements the protocol's security requires. But I am happy to add elements that add robustness to the protocol (against misuse, etc.). I had examples in the past that I thought adding idU would be useful but I do not remember. It seems that if servers choose per-user kU (which they should) then adding idU does not add much value. Otoh, it makes idU more static as you cannot decide to change idU after registration (some websites would let you change userid)",
          "createdAt": "2020-10-20T06:29:51Z",
          "updatedAt": "2020-10-20T06:29:51Z"
        },
        {
          "author": "huitseeker",
          "authorAssociation": "NONE",
          "body": "> some form of user identity needs to be sent to the server for fetching the user's record.\r\n\r\nI think this hinges on whether the protocol is described as a component of a session (L5+). It seems to me that this is one natural way of interpreting (or implementing) the Registration flow, on the one hand, and the Credential flow, on the other hand. During each of those, the idU parameter remains a constant.\r\n\r\nOnce the session parameters are determined \u2014 including of course the user's claim to identity (idU) \u2014 there is no need for the application to receive them again in further messages. The repetition would in fact no only consume bandwidth, but complicate implementation, by requiring a check that the idU value has indeed been kept constant on every message of a session, and demanding that the server emits a new error case if that session invariant is broken.\r\n\r\nHowever, such a re-transmission may be useful for auxiliary stateless tooling that does not have an understanding of a session, such as firewalls implementing packet filtering based on the idU field.\r\n\r\nWe've worked on implementation with a L7 in mind, but it's perfectly understandable that you could think of OPAQUE + KE as a lower-level initial session establishment protocol, in which case the stateless interpretation would make sense. \r\n\r\nAre there two recommendations to make to implementers here, depending on their use case?  \r\n\r\n",
          "createdAt": "2020-10-20T18:23:51Z",
          "updatedAt": "2020-10-20T18:24:26Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to be extra clear -- the inefficiency I am highlighting is the fact that the idU parameter included by RegistrationRequest is never used by the OPAQUE server implementation. Leaving it out would have no impact on anything within OPAQUE. One could argue the use for it by a wrapper protocol, but then the wrapper protocol would need to inspect the bytes of the OPAQUE protocol in order to extract idU, which could change depending on the OPAQUE version, and in general does not seem like a good abstraction.\r\n\r\nFor CredentialRequest, the same is true, except that the AKE component may use idU. However, I believe we should include the idU in the \"first message of the key exchange\" if the specification for that key exchange so requires, rather than placing it next to the OPRF component where it may or may not be consumed by the AKE.\r\n\r\nBTW @hugokraw, I believe the idU parameter is already optional (since it can be specified as 0 bytes as per \"`opaque id<0..2^16-1>;`\"). The question I am asking is if we should remove the already-optional parameter from the message being sent from client to server.",
          "createdAt": "2020-10-20T18:49:55Z",
          "updatedAt": "2020-10-20T18:49:55Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not completely sure I understand the issue here. I can see that there are cases where sending IdU inside OPAQUE can be redundant or even complicate things. But I think that giving the option to send it as part of the OPAQUE messages is necessary for ensuring one standard way for signaling the userid information to the server when the wrapper/application around it is not doing so. If you take the ability to send userid completely out of OPAQUE, what would be the answer to people's question \"how is the client supposed to communicate the identity of the user to the server\"?. Would the answer be:  \"it is not OPAQUE's responsibility but rather the application/wrapper around it\"? \r\n\r\nA related issue is privacy of the user id/account information. If you send it as part of OPAQUE and you run OPAQUE inside a confidential channel, such as server-authenticated TLS, then you get that protection. If you send it by other means, you need to trust that this other means take care of privacy. \r\n\r\nOnce thing that is **for sure** is that the AKE needs to have a notion of identities agreed by both parties (agreement needs to be at the level of bit representation as these are input into the KDF) as verifying such agreement is a fundamental part of the AKE functionality. Since these identities will be known in most cases to the parties before the AKE starts (the server needs it to fetch the user's record and the user will typically have an identity of the server in order to contacting it), sending it in the AKE may be redundant in some/many cases. But I am ok with any decision here as long as we make sure this agreement on identities is established before running the authentication steps in the AKE.",
          "createdAt": "2020-10-21T15:41:26Z",
          "updatedAt": "2020-10-21T15:41:26Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I am not completely sure I understand the issue here. I can see that there are cases where sending IdU inside OPAQUE can be redundant or even complicate things. But I think that giving the option to send it as part of the OPAQUE messages is necessary for ensuring one standard way for signaling the userid information to the server when the wrapper/application around it is not doing so. If you take the ability to send userid completely out of OPAQUE, what would be the answer to people's question \"how is the client supposed to communicate the identity of the user to the server\"?. Would the answer be: \"it is not OPAQUE's responsibility but rather the application/wrapper around it\"?\r\n\r\nThat's correct, I am of the opinion that \"it is not OPAQUE's responsibility but rather the application/wrapper around it\"\r\n\r\n> A related issue is privacy of the user id/account information. If you send it as part of OPAQUE and you run OPAQUE inside a confidential channel, such as server-authenticated TLS, then you get that protection. If you send it by other means, you need to trust that this other means take care of privacy.\r\n> \r\n> Once thing that is **for sure** is that the AKE needs to have a notion of identities agreed by both parties (agreement needs to be at the level of bit representation as these are input into the KDF) as verifying such agreement is a fundamental part of the AKE functionality. Since these identities will be known in most cases to the parties before the AKE starts (the server needs it to fetch the user's record and the user will typically have an identity of the server in order to contacting it), sending it in the AKE may be redundant in some/many cases. But I am ok with any decision here as long as we make sure this agreement on identities is established before running the authentication steps in the AKE.\r\n\r\nAgreed on the AKE point. I am also ok with leaving it as an optional parameter in RegistrationRequest and CredentialRequest, but I do want to point out that this idU parameter is the only remaining parameter in the OPAQUE protocol which is sent over the wire, but the receiving party does not do anything with it (within the specification).\r\n\r\nTo me, the rule I'd like to follow is: the only code which should be interpreting / deserializing any bytes sent as part of the OPAQUE protocol is the OPAQUE code itself -- having a wrapper protocol attempt to do the deserialization may end up causing versioning / upgrading nightmares for these wrapper implementations. As such, I'd like to avoid the possibility of a wrapper call understanding the organization of bytes in the OPAQUE messages, and hence would lean towards completely omitting this idU in OPAQUE's RegistrationRequest and the core part (not the AKE part) of CredentialRequest.",
          "createdAt": "2020-10-21T21:50:16Z",
          "updatedAt": "2020-10-21T21:50:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi can you please prep a PR with this suggested change?",
          "createdAt": "2020-10-21T22:35:24Z",
          "updatedAt": "2020-10-21T22:35:24Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I said in a previous post in this thread:\r\n> I had examples in the past that I thought adding idU [in the OPRF input, in addition to the password] would be useful but I do not remember\r\n\r\nSo now I remembered: It helps against an online attack where the attacker poses as the server with its own chosen value k*. If only pwd is included then, the attacker can build a universal dictionary of values H(pwd)^k* for all pwd in a dictionary and use it against any user to check the client response. On the other hand, if idU is included under H then the attacker needs to build a dictionary per idU.  This would mean that at login and before talking to the server, the client knows a value of idU that was set at registration. If this is considered too problematic, one can live with the above issue as online attacks, particularly from the server side are not so damaging (I think). One can also include the server identity under H as may always be needed by the client in order to contact the server.",
          "createdAt": "2020-10-22T15:08:19Z",
          "updatedAt": "2020-10-22T15:08:19Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWU3MjY4NjkzNTc=",
      "title": "Allow OPRF context creation with external key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/67",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is more of an issue with the OPRF draft, but noting it here for now. The OPRF context constructor does not allow creation of a server with an existing key, which makes the OPRF credential response generation function somewhat annoying to implement. ",
      "createdAt": "2020-10-21T21:16:22Z",
      "updatedAt": "2020-11-02T23:54:06Z",
      "closedAt": "2020-11-02T23:54:06Z",
      "comments": []
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWU3MjY4Njk4NTE=",
      "title": "OPRF evaluation output",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/68",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The output of `Evaluate` in the OPRF draft is an `Evaluation` object, which has both a blinded and signed element, as well as a proof. We should either adopt that type here, or make it clear in our notation that the output of `Evaluate` is just the blinded and signed element.\r\n\r\nNote that this affects what's carried in a `RequestMetadata` struct. ",
      "createdAt": "2020-10-21T21:17:15Z",
      "updatedAt": "2020-12-21T17:00:15Z",
      "closedAt": "2020-12-21T17:00:15Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Aside from the specification issues, I would explicitly note (if not done yet) that we use the OPRF without proof/verifiability. Doing so would require the user to carry the g^kU value with him/her contradicting the password-only property of OPAQUE.",
          "createdAt": "2020-10-22T14:41:01Z",
          "updatedAt": "2020-10-22T14:41:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I clarified this with a text change right on master. Closing.",
          "createdAt": "2020-12-21T17:00:15Z",
          "updatedAt": "2020-12-21T17:00:15Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWU3MjY4NzEwNjQ=",
      "title": "Specify harden parameters",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/69",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Clients need a way to recover credential information during registration. So we should either (a) fix some Harden parameters, or (b) have servers send these during the registration and authentication flows. \r\n\r\n@kevinlewi, what do you think?",
      "createdAt": "2020-10-21T21:19:22Z",
      "updatedAt": "2020-10-28T13:03:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can you clarify what you mean by (a)? If you mean to provide concrete settings, I think we may want to avoid that since these numbers can become out of date, and are application-dependent. For (b), I think we should avoid this as well, unless we start also deciding to send information about group representation / hash functions during these flows. Also, there is no way for the server to enforce that the client follows the harden parameters, and so these are at best recommendations.\r\n\r\nMy approach would be to allow for parameterizing the protocol based on harden parameters. So in the same way that we can have OPAQUE with Ristretto points versus Edwards, or OPAQUE with SHA3 versus Blake3, the choice of a hardened hash function should just be another parameter.",
          "createdAt": "2020-10-21T22:12:30Z",
          "updatedAt": "2020-10-21T22:12:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ">  If you mean to provide concrete settings, I think we may want to avoid that since these numbers can become out of date, and are application-dependent. \r\n\r\nYeah, that's what I mean, and that's the risk. \r\n\r\n> My approach would be to allow for parameterizing the protocol based on harden parameters. So in the same way that we can have OPAQUE with Ristretto points versus Edwards, or OPAQUE with SHA3 versus Blake3, the choice of a hardened hash function should just be another parameter.\r\n\r\nI think there's generally too much flexibility in what's currently in the document. We have ciphersuites, configurations, optional parameters, etc. All of this runs the risk of making implementations challenging to get right. I would be in favor of something a bit more rigid. Could you please draft a PR to take care of this with your proposal? (This would also ideally address #58.)",
          "createdAt": "2020-10-21T22:35:00Z",
          "updatedAt": "2020-10-21T22:36:27Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I might have misinterpreted, but I was not suggesting to modify the current proposal in any way, except to suggest that when producing test vectors, we have a set which instantiates Harden with a specific function.\r\n\r\nSo my proposal is to keep everything in the draft the same, and when presenting test vectors, we provide annotated options such as:\r\n- OPAQUE-X25519-3DH-SHA256-Scrypt10k,\r\n- OPAQUE-Ristretto255-SigmaI-Blake3-Argon2i100k,\r\n- etc.\r\n\r\nThis means that we will be supporting the increased flexibility that you may be against.\r\n\r\nBtw, while we are on the topic, the flexible parameters I am currently tracking are:\r\n- Group representation\r\n- Keypair format\r\n- AKE protocol\r\n- Hash function\r\n- Harden function\r\n\r\n(Also represented in code [here](https://github.com/novifinancial/opaque-ke/blob/master/src/ciphersuite.rs#L15-L23))\r\n\r\nLet me know if you think I am missing any others...",
          "createdAt": "2020-10-21T22:48:43Z",
          "updatedAt": "2020-10-21T22:48:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Those match my understanding, yeah. Do we really *need* this sort of flexibility? I'm not sure! \r\n\r\nThough, hmm... on reflection, why are the parameters of Harden something the configuration (server?) ought to specify at all?",
          "createdAt": "2020-10-22T00:01:18Z",
          "updatedAt": "2020-10-22T00:01:18Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed, I don't think the specification needs to specify the parameters of Harden, but an implementation may want to provide options for configuring them.",
          "createdAt": "2020-10-22T01:15:24Z",
          "updatedAt": "2020-10-22T01:15:24Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After some offline discussion, we have settled on the following as the main point of discussion:\r\n\r\nLet's suppose a client registers their password using a particular hardening function. How should the client on login know what parameters for the hardening function to use? Two potential options:\r\n1) This shouldn't be part of the OPAQUE protocol, and it should be the responsibility of the wrapping protocol to ensure that the login surface's hardening parameters match those of registration, or to optionally store an annotation at registration time to help inform what parameters to use for login.\r\n2) This should be incorporated into OPAQUE, potentially through an extra client-specified field that can be stored alongside the password file.\r\n\r\nIf we go with Option 2, there are more follow-up questions, such as whether or not this field should be free-form, if it should be authenticated, etc.\r\n\r\ncc: @chris-wood",
          "createdAt": "2020-10-22T02:42:14Z",
          "updatedAt": "2020-10-22T02:42:14Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If the hardening parameters are transmitted from server to client, it would be better to authenticate them, or otherwise a cheating server can either apply a DoS attack on the client by sending extremely large parameters or help in a dictionary attack with small parameters (the latter would only apply to an online attack posing as the server).",
          "createdAt": "2020-10-22T14:58:20Z",
          "updatedAt": "2020-10-22T14:58:20Z"
        },
        {
          "author": "huitseeker",
          "authorAssociation": "NONE",
          "body": "I vote for option 1: This shouldn't be part of the OPAQUE protocol. While it's one of the strengths of the abstract protocol to be generic, in practice deployments will be content with one particular suite of sub-protocols (for each of the available choices). \r\n\r\nAllowing the server to fix a set of choices without any further variability in messages avoids the headache of downgrade attacks.",
          "createdAt": "2020-10-22T17:17:09Z",
          "updatedAt": "2020-10-22T17:17:09Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "MDU6SXNzdWU3MjY5OTM2MDk=",
      "title": "Why does FinalizeRequest take in idU as a parameter?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/72",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "According to [this](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L651), idU is used to construct FinalizeRequest, despite it only being applicable if the application decides to include it in the Credentials struct: > \"Applications may optionally include\r\n> `pkU`, `idU`, or `idS` in the `Credentials.cleartext_credentials` structure, or in\r\n> `Credentials.secret_credentials` if secrecy of these values is desired.\"\r\n\r\nBut if this is the case, then why not also make idS and pkU parameters to FinalizeRequest as well?\r\n\r\nSame goes for RecoverCredentials. Either they should take in all of these optional parameters as inputs, or they should not include any of them.",
      "createdAt": "2020-10-22T02:32:52Z",
      "updatedAt": "2020-10-28T18:59:00Z",
      "closedAt": "2020-10-28T18:59:00Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposal: remove application-specific credential information from the parameter list, and call out to the application to build `Credentials` based on the server's `secret` and `cleartext` list.",
          "createdAt": "2020-10-23T21:09:43Z",
          "updatedAt": "2020-10-23T21:09:43Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWU3MzAwNzYyODg=",
      "title": "Clarifying optional versus required parameters in the AKE section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/74",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In this [section on AKE](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1008-L1014), we should clear up exactly which parameters are required and which are optional. Then we can also work towards defining a wire format for these AKEs if necessary.\r\n\r\nA couple of concrete questions:\r\n1) Can we simply set idU = static pkU and idS = static pkS?\r\n2) Can we remove mention of all of the following: info1*, info2*, Einfo2*, info3*, Einfo3*?\r\n",
      "createdAt": "2020-10-27T03:42:24Z",
      "updatedAt": "2020-11-12T23:41:22Z",
      "closedAt": "2020-11-12T23:41:22Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> 1. Can we simply set idU = static pkU and idS = static pkS?\r\n\r\nThis had been discussed in the past, and I think it depends on whether or not there exists a secure binding between the public key(s) and corresponding identity. (And that seems mostly external to the protocol.) I need to think about this more. @hugokraw probably also has opinions. :-)\r\n\r\n> 2. Can we remove mention of all of the following: info1*, info2*, Einfo2*, info3*, Einfo3*?\r\n\r\nThese fields exist to make the AKE instantiation more generic, e.g., maybe `info1` contains the client's set of application protocols run on top of the AKE. I think we should remove them, since applications that need this flexibility should be using TLS. I view the 3DH and SIGMA-I variants as minimalist OPAQUE instantiations. ",
          "createdAt": "2020-10-28T13:01:30Z",
          "updatedAt": "2020-10-28T13:01:30Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding point 1: In general, identities refer to logical entities on the basis of which policy decisions by the receiving party are made (do I want to talk to this identity, under what security level, which access rights, etc.) A public key may be used as an identity but most of the time it is not (e.g. , it is the subject in a certificate rather than the public key). In the case of OPAQUE,  using public keys may be more acceptable since those are fixed after registration and the client authenticates the server's public key via the password. I am not sure if this means that the client will never need to make decisions based on the server's logical identity but I do not see an obvious setting where this is the case. However, note that in the three protocols in the draft, the client does not use the user's public key. So if we are going to use it then we either send it as part of the authenticated information in the envelope or require the client to re-compute it from the user's private key at the cost of an exponentiation.",
          "createdAt": "2020-10-28T16:28:57Z",
          "updatedAt": "2020-10-28T16:28:57Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding point 2: We want these AKEs to be minimalistic but not useless. I do not see the case of any key exchange protocol that does not require sending some additional setting-specific information in its flows. Instead of having these fields named specifically, you may define some extensibility mechanism to transport additional information, but some mechanism for that must exist.",
          "createdAt": "2020-10-28T16:31:11Z",
          "updatedAt": "2020-10-28T16:31:11Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for the comments!\r\n\r\nFor point 1: I would be in favor of requiring the client to re-compute the user's public key from its private key at the cost of an exponentiation, if it means that we do not need to send idU over the wire for the KE1 message. Similarly, for idS, since the server's public key is already required to be a part of the authenticated envelope, I would be in favor of omitting idS from the KE2 message as well (it is not currently there but just in case that comes up).\r\n\r\nFor point 2: Fair enough, we can keep them as optional parameters, but just to double-check, for the sake of minimalism: do you think we need both the plaintext variants (info1*, info2*, info3*) in addition to the encrypted variants (Einfo2*, Einfo3*), or would one set of these suffice?",
          "createdAt": "2020-10-28T18:56:53Z",
          "updatedAt": "2020-10-28T18:56:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding point 2, why can't applications send info *after* the AKE completes? (I understand that it burns a round trip, but that seems preferable to additional complexity in the AKE protocol itself.) In other words, an AKE without application slots is *not* useless. It's minimal, and allows applications to build whatever it is they need on top. \r\n\r\nSimply put, absent a specific use case for extensions, I'm not convinced they need to exist. ",
          "createdAt": "2020-10-28T19:15:02Z",
          "updatedAt": "2020-10-28T19:16:19Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The plaintext info field may be needed to transport information needed to select the algorithms and type of protection applied by the AKE and cannot be postponed to after the end of the AKE. The encrypted info field may be needed to transport information that requires privacy. I am all for simplifying wherever possible but I also want a usable specification. Eliminating all information beyond the core crypt operations does not seem to lead to such usable specification.  \r\n\r\nI am ok with letting pkU and pkS act as identities but I can also see implementations that would prefer to use something like a uid@site.dom as idU and save the computation of pkU. Would you be ok with having the id's be optional elements in the envelope (but omitted from the AKE messages)? \r\n ",
          "createdAt": "2020-10-28T22:10:20Z",
          "updatedAt": "2020-10-28T22:10:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The plaintext info field may be needed to transport information needed to select the algorithms and type of protection applied by the AKE and cannot be postponed to after the end of the AKE. \r\n\r\nI'm not sure I agree with this. If cryptographic algorithm negotiation is needed for the AKE, then we should specify the mechanics to do that. We shouldn't just provide a generic slot for application info and punt the problem downstream. (Or, put differently, leaving just `info` and assuming it'll be used for cryptographic algorithm negotiation is an underspecified AKE, and not something applications can implement safely or correctly on their own.)\r\n\r\n> The encrypted info field may be needed to transport information that requires privacy. \r\n\r\nIf privacy is required, this information can be sent after the AKE completes. Why does it need to be done in-band?\r\n\r\n> I am all for simplifying wherever possible but I also want a usable specification. Eliminating all information beyond the core crypt operations does not seem to lead to such usable specification.\r\n\r\nI think it's the opposite. If we keep the specification as minimal as I'm advocating for, then applications are free to use the AKE's output however they want. ",
          "createdAt": "2020-10-28T22:22:40Z",
          "updatedAt": "2020-10-28T22:24:12Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Would you be ok with having the id's be optional elements in the envelope (but omitted from the AKE messages)?\r\n\r\nI believe idU and idS can already be specified as optional elements in the envelope (see [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L438-L439)), and so I would be happy to go with omitting them from the AKE messages.",
          "createdAt": "2020-10-28T22:29:19Z",
          "updatedAt": "2020-10-28T22:29:19Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Would you be ok with having the id's be optional elements in the envelope (but omitted from the AKE messages)?\r\n> \r\n> I believe idU and idS can already be specified as optional elements in the envelope (see [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L438-L439)), and so I would be happy to go with omitting them from the AKE messages.\r\n\r\nOk. So we can eliminate them from the AKE messages but have an explicit specification that the values idU and idS in the KDF are those specified in the envelope or, if omitted there, then pkU and pkS  (with a note that pkU will need to be computed by the client if not transmitted in the envelope).\r\n\r\n\r\n",
          "createdAt": "2020-10-28T22:32:38Z",
          "updatedAt": "2020-10-28T22:32:38Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think it's the opposite. If we keep the specification as minimal as I'm advocating for, then applications are free to use the AKE's output however they want.\r\n\r\nThe are always free to use the AKE output however they want. The question is whether they will have enough information to run and complete the AKE if they cannot send more than the bare cryptographic elements during the AKE. \r\n",
          "createdAt": "2020-10-28T22:37:09Z",
          "updatedAt": "2020-10-28T22:37:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The are always free to use the AKE output however they want. The question is whether they will have enough information to run and complete the AKE if they cannot send more than the bare cryptographic elements during the AKE.\r\n\r\nAs specified currently, and ignoring the `info` fields, is this the case? If so, shouldn't we specify everything that's needed to complete the AKE in this spec? I don't see how we can punt on that!",
          "createdAt": "2020-10-28T22:38:55Z",
          "updatedAt": "2020-10-28T22:38:55Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> As specified currently, and ignoring the `info` fields, is this the case? If so, shouldn't we specify everything that's needed to complete the AKE in this spec? I don't see how we can punt on that!\r\n\r\nI am thinking of these AKEs as something people will need to customize to their application/setting. The usage by Facebook and the ones by AWS are very different and they will need to fill in the details according to their needs.",
          "createdAt": "2020-10-28T22:44:40Z",
          "updatedAt": "2020-10-28T22:44:40Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If it helps (I am not fully convinced), I am ok with removing info and einfo in the current description, and instead adding language saying that what is shown is the minimal cryptographic skeleton and that applications may need to transport additional information as part of the AKE. In such a case, any information transmitted as part of the AKE messages must be included in the transcript fields (that are mac-ed in 3DH/HMQV and signed in SIGMA).  In addition, we specify the derivation of authenticated encryption keys (denote Ke2, Ke3) to be used for confidentiality protection of elements in the transcript that require such protection.",
          "createdAt": "2020-10-28T23:07:17Z",
          "updatedAt": "2020-10-28T23:07:17Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since the discussion on point #2 seems to be around either: leaving in the optional parameters info and einfo, or omitting them entirely, it seems like the tradeoffs are the following:\r\n\r\nPros for leaving in the optional parameters info* and einfo*:\r\n- A potential application that wants to use these fields can do so without having to wait the extra round trip for AKE to finish\r\n\r\nCons for leaving in the optional parameters info* and einfo*:\r\n- Increased spec / API complexity for implementers\r\n- Increased bandwidth due to bytes spent on length-prefixing the optional parameters in AKE even if they are not used\r\n\r\nIs this an accurate summary? If so, I am leaning slightly towards keeping in the optional parameters, but not with a strong preference :) ",
          "createdAt": "2020-10-28T23:22:52Z",
          "updatedAt": "2020-10-28T23:22:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is this an accurate summary? If so, I am leaning slightly towards keeping in the optional parameters, but not with a strong preference :)\r\n\r\nYeah, I think that's mostly accurate. Can you elaborate on why you're leaning that way? (If you used them in your implementation, what were the values of the fields?)",
          "createdAt": "2020-10-28T23:33:51Z",
          "updatedAt": "2020-10-28T23:33:51Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "My feeling is that we serve better the potential implementers of OPAQUE that need to embed the protocol in their specific application by guiding them toward they way of adding application specific elements to the protocol, in particular telling them that they should add these elements to the authenticated transcript and use Ke to protect confidentiality if needed. As I wrote elsewhere, I am ok if we remove info, einfo from the spec but then we must have English text about the need to include such elements under the authenticated transcript. Also noting the potential need for Ke (which we would include in the key derivation even if we do not show einfo* explicitly).  My bottom line: We would be serving implementers of OPAQUE in specific applications better with the info fields than without. (But who am I to tell what implementers really need? :-)\r\n ",
          "createdAt": "2020-10-28T23:36:24Z",
          "updatedAt": "2020-10-28T23:36:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> My bottom line: We would be serving implementers of OPAQUE in specific applications better with the info fields than without.\r\n\r\nYeah, I think if the goal is to allow applications to build a one-off AKE specific to their use case, then I think this is the right call. If, on the other hand, we're specifying a feature-complete AKE in this spec, I lean the other way. ",
          "createdAt": "2020-10-28T23:38:54Z",
          "updatedAt": "2020-10-28T23:38:54Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Is this an accurate summary? If so, I am leaning slightly towards keeping in the optional parameters, but not with a strong preference :)\r\n> \r\n> Yeah, I think that's mostly accurate. Can you elaborate on why you're leaning that way? (If you used them in your implementation, what were the values of the fields?)\r\n\r\nOne example that comes to mind is the following: Suppose a client is using a password to log in to a server, and on the KE2 message, the server wants to send to the client auxiliary information about the last time the client successfully logged in (IP address, # of incorrect login attempts since last login, etc.). These are of course things that can wait 1 more round trip for, but in certain applications it may be more convenient to not have to wait.\r\n\r\nAnyway, the main reason why I am leaning towards including the optional parameters is because I feel like we are more likely to regret excluding them than the other way around. I believe the added API complexity only affects those who have to implement a spec-compliant OPAQUE (hopefully a small population) and the benefits of having the flexiblity to use these optional parameters would affect those who use the spec-compliant OPAQUE implementations (hopefully a larger population).\r\n\r\n@huitseeker in case he has any additional thoughts on this",
          "createdAt": "2020-10-29T00:06:49Z",
          "updatedAt": "2020-10-29T00:06:49Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> I feel like we are more likely to regret excluding them than the other way around\r\n\r\nI would have not dared to show my feelings like Kevin's but I strongly feel like him :-)\r\n\r\n",
          "createdAt": "2020-10-29T02:22:07Z",
          "updatedAt": "2020-10-29T02:22:07Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yeah, I think if the goal is to allow applications to build a one-off AKE specific to their use case, then I think this is the right call. If, on the other hand, we're specifying a feature-complete AKE in this spec, I lean the other way.\r\n\r\nThis is indeed the point in which our view diverge. I hear of several people with various interests, including Kevin/Facebook, Crockett/AWS and people from some banks. They were all talking of specific applications they have rather than using a general Web/TLS-based protocol. I think that the document we are writing needs to serve these people. It can also serve those integrating OPAQUE in other protocols IKEv2, SSH, ...",
          "createdAt": "2020-10-29T02:26:22Z",
          "updatedAt": "2020-10-29T02:26:22Z"
        },
        {
          "author": "huitseeker",
          "authorAssociation": "NONE",
          "body": "Optional information parameters can be useful, and if the past is prologue, they'll eventually be useful to shave off round-trips on auxiliary data in what's after all a latency-sensitive initial setup.\r\n\r\nSo, in that regard, if we keep those useful parameters in:\r\n- might it make sense to be very clear on what guarantees (as to authentication, compromise resistance, resistance to key compromise ...) the server can expect at the time it sends these optional parameters?\r\n- would it make sense to make an opt-in to those parameters a strong signal, maybe by committing to it in a ciphersuite string?",
          "createdAt": "2020-11-02T20:56:00Z",
          "updatedAt": "2020-11-02T20:56:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, on reflection, I think keeping the parameters is probably the best path forward. @kevinlewi, how do you want to deal with point (1)?",
          "createdAt": "2020-11-02T23:53:49Z",
          "updatedAt": "2020-11-02T23:53:49Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For #1, recapping the summary from @hugokraw :\r\n\r\n> Ok. So we can eliminate them from the AKE messages but have an explicit specification that the values idU and idS in the KDF are those specified in the envelope or, if omitted there, then pkU and pkS (with a note that pkU will need to be computed by the client if not transmitted in the envelope).\r\n\r\nSo, let's remove their presence from the AKE messages, and I would vote for setting idU = pkU and idS = pkS when computing the AKE components (instead of reusing idU and idS that were optionally specified in the envelope).",
          "createdAt": "2020-11-03T00:42:23Z",
          "updatedAt": "2020-11-03T00:42:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems reasonable to me. Can you please draft a PR?",
          "createdAt": "2020-11-03T03:01:58Z",
          "updatedAt": "2020-11-03T03:01:58Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> So, let's remove their presence from the AKE messages, and I would vote for setting idU = pkU and idS = pkS when computing the AKE components (instead of reusing idU and idS that were optionally specified in the envelope).\r\n\r\nDo you mean removing idU and idS from the envelope, even as optional, and always using pkU and pkS as the identities in the AKE? I am responding to that interpretation. If that's not what you were saying, ignore this.\r\n\r\n Identities are central to authorization, access control, etc. and password protocols are central to these services so I think we need to leave flexibility there. Having the optional idU, idS in the envelope and pkU, pkS as default seems like a good balance between flexibility and ease of implementation.",
          "createdAt": "2020-11-03T06:14:31Z",
          "updatedAt": "2020-11-03T06:14:31Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@hugokraw That is not quite what I mean; I am all for keeping idU and idS as optional parameters in the envelope. However, the **AKE portion** also refers to idU and idS: in particular, the values referenced [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1138-L1139). The question is -- should these simply be set to idU = pkU and idS = pkS, or should they be the same idU and idS that were optionally specified in the envelope?\r\n\r\nI am advocating for idU = pkU and idS = pkS just for the **AKE portion**, the values [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1138-L1139). It would be great to get your thoughts on this!",
          "createdAt": "2020-11-04T21:12:56Z",
          "updatedAt": "2020-11-04T21:12:56Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "There is no use for idU and idS transported in the envelope other than to serve as identities in the AKE in lieu of any other identity that the parties may use to initially identify each other (for the client to know which server to contact and for the client to let the server know what user record to fetch). For example, I use hugokraw as my moniker in github but github may actually use my email address as my official identity (I don't know if this is the case, it is an imaginary example as far as I can tell).  I find it too limiting to dictate applications what's the identity they want to bind the AKE to.",
          "createdAt": "2020-11-05T06:23:34Z",
          "updatedAt": "2020-11-05T06:23:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Summary of discussion from the call: If there is no identity in the envelope, the AKE ID matches the public key. Conversely, if there is an identity in the envelope, that is the used in AKE.\r\n\r\n@hugokraw, @kevinlewi: does this match your understanding? \r\n\r\nIf so, we should elaborate on [this section](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#name-ake-execution-and-party-ide) to explain the differences between these identities and their respective use cases. In the process, we should recommend one implementation strategy for applications, e.g., by recommending that the AKE ID be the public key, and if a separate identity is desired, it's put in the envelope. In doing so, we should add text to deal with the case where application identities are long -- perhaps too long to store in the envelope. In such cases, a hash of the identity might be stored in the envelope and threaded into the AKE, and the server needs to check the hash against the long-form identity. ",
          "createdAt": "2020-11-06T22:58:29Z",
          "updatedAt": "2020-11-06T23:04:51Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Excellent -- yes, thank you, this matches my understanding!\r\n\r\nJust to double-check, the same logic applies for idS, of course, right? (Default to pkS, unless idS is specified in the envelope, in which case use that)",
          "createdAt": "2020-11-06T23:10:41Z",
          "updatedAt": "2020-11-06T23:10:41Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Good (and yes, same logic for idS).\r\n\r\nNote: Currently, [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#finalizerequest) we say \"Applications may optionally include pkU, idU, or idS....\" in the envelope. We may want to clarify that if pkU is to be used as idU, this value needs to be sent in the envelope or the client would need to compute pkU from skU.\r\n",
          "createdAt": "2020-11-07T05:12:23Z",
          "updatedAt": "2020-11-07T05:12:23Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood @hugokraw Thanks! There is one more edge case to discuss:\r\n\r\nSuppose idU and idS are part of the envelope, but they are stored as a secret_credential (encrypted under `rwdU`) as opposed to something that the server can read in plaintext? The server will not be able to perform the AKE key derivation since it cannot read these values in place of idU and idS.\r\n\r\nAlso, what if they are stored authenticated in the envelope under cleartext_credentials? Do we expect the server to read the values without trying to check the MAC on them (since that would also require `rwdU`)?\r\n\r\nOf course, one way to simplify all of this is to simply default idU = pkU and idS = pkS and not try to have the server read the envelope's contents.",
          "createdAt": "2020-11-09T05:13:59Z",
          "updatedAt": "2020-11-09T05:15:04Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If idU and/or idS are stored under secret_credential, the server needs some other form of access to these values. The server cannot decrypt or authenticate the envelope; only the client in possession of the password (and after computing rwdU) can. Typically, the server will store these values separately or can derive them from other information it has, e.g., it knows its own identity idS or it derives idU from the identity it uses to identify the user's record. If the values are stored in the envelope in cleartext, the server can choose to read them from there; it is an implementation issue.",
          "createdAt": "2020-11-09T15:48:19Z",
          "updatedAt": "2020-11-09T15:48:19Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Makes sense. In that case, I propose that we set the default behavior to use idU = pkU and idS = pkS. And then, if the wrapper protocol wishes to use a custom idU and idS, then the OPAQUE protocol can accept these custom parameters from the wrapper protocol and use them in the AKE instead. Thus, the envelope would be completely ignored when doing this calculation.",
          "createdAt": "2020-11-09T19:05:13Z",
          "updatedAt": "2020-11-09T19:05:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If the envelope's identities are (effectively) ignored, would we keep idU and idS as valid credential types?",
          "createdAt": "2020-11-09T20:17:20Z",
          "updatedAt": "2020-11-09T20:17:20Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood That's a fair question -- perhaps we can create a separate issue to discuss the inclusion of idU and idS in the envelope, once we land the changes prescribed here?",
          "createdAt": "2020-11-09T20:21:53Z",
          "updatedAt": "2020-11-09T20:21:53Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The question is whether the client needs to accept the identities provided by the wrapper as the client cannot authenticate those. If authentication is needed then one must either use the default pkS identity for S or otherwise idS needs to be authenticated by the envelope. To illustrate the need for authentication, consider a setting where the application running on the client side has an access control policy with some permission rules for accessing a resource R.  Both idS and idS* are known server names to which the user may connect so both names have defined permissions for resource R. Note that the policy is defined in terms of names, not public keys (as with subject names in certificates vs.  public keys), and the names are received from the AKE layer once authentication succeeds (the AkE may pass several elements to the higher layers, including the peer's identity).\r\n\r\nNow suppose the client connects to idS who runs a rogue wrapper that provides the client with the correct envelope for idS but gives idS* as the identity.  The client will end the AKE successfully but with identity idS*. Indeed, the server (whose real name is idS) will authenticate using his own private key (corresponding to the public key in the envelope) but will enter the name idS* to the AKE which the client will do too (as it is using the identity provided by the wrapper). So the AKE level will pass to the access control policy the identity idS* and idS (not idS*) will be granted access to resource R.\r\n",
          "createdAt": "2020-11-09T22:36:22Z",
          "updatedAt": "2020-11-09T22:36:22Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@hugokraw I am not entirely sure if you are proposing that we deviate from my [above comment](https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/74#issuecomment-724214162) (it seems like you are still in agreement), but I think to address the concern that you mentioned, the OPAQUE implementation should simply surface both idS (found in the envelope) and idS* (as output by the AKE) to the client, and allow the wrapper protocol on the client side decide whether or not it is valid for idS != idS*. Similarly for idU / idU* on the server-side.\r\n\r\n\r\n",
          "createdAt": "2020-11-09T23:34:54Z",
          "updatedAt": "2020-11-09T23:34:54Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If I understand correctly your proposal, it says: \"Either use the default identities pkU, pkS, or let the wrapper decide on these identities.\" This presumes the wrapper application to be trusted and a final decision maker on what identities are acceptable.\r\nIn this case, I do not see the need to ever transport identities in the envelope. Or do you still think there is a point in allowing identities in the envelope in this case? How would they be used? \r\n\r\nI don't have an opinion on the trust one should put on the wrapper (I don't have enough use cases in mind to reason about it), but I'd hesitate to specify OPAQUE with such a universal trust assumption. It feels safer  (but maybe too limiting?) to make all decisions based on what OPAQUE can validate. Namely, follow the strict policy by which AKE identities are defined in the envelope and if they are missing from it then they default to pkU and pkS.",
          "createdAt": "2020-11-10T06:18:55Z",
          "updatedAt": "2020-11-10T06:18:55Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, I think this makes sense, and we can first check for the existence of the identities in the envelope, and if they are missing, default to pkU and pkS (as we agreed to in [this comment](https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/74#issuecomment-723337010)).\r\n\r\nBut just as an FYI, since we must distinguish between the OPAQUE protocol run on the server versus the wrapper protocol that calls OPAQUE on the server, this means that the OPAQUE server protocol will have to **ask the wrapper protocol for the idU and idS it should use for the AKE**, since it cannot decrypt/authenticate the contents of the envelope. Just want to make sure we are clear on that.\r\n\r\nIf so, I believe we are good to go.",
          "createdAt": "2020-11-10T22:07:12Z",
          "updatedAt": "2020-11-10T22:07:12Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "There are many ways in which the server can decide on the values of idS and idU. It can indeed ask the wrapper for those values but it could also  set idS and idU at registration (or later) and store them in the user's record, or it can read these values from the envelope if stored unencrypted there.  All these options are legit. \r\nNote that the setting here is very different for the user and server.  The user has no way of authenticating anything other than with his password (hence it can only authenticate information in the envelope) but the server has local storage with information (e.g., idS and idU) that it can trust.",
          "createdAt": "2020-11-11T04:01:54Z",
          "updatedAt": "2020-11-11T04:01:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi I think we can close this as resolved now. Do you want to do the honors?",
          "createdAt": "2020-11-12T23:32:38Z",
          "updatedAt": "2020-11-12T23:32:38Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks everyone for engaging in the discussions!",
          "createdAt": "2020-11-12T23:41:21Z",
          "updatedAt": "2020-11-12T23:41:21Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWU3MzA5ODIzNDM=",
      "title": "Swap 3DH label strings around",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/75",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the 3DH key schedule computes two MAC and two encryption keys, as follows:\r\n\r\n```\r\nKm2 = HKDF-Expand-Label(handshake_secret, \"client mac\", \"\", Hash.length)\r\nKm3 = HKDF-Expand-Label(handshake_secret, \"server mac\", \"\", Hash.length)\r\nKe2 = HKDF-Expand-Label(handshake_secret, \"client enc\", \"\", key_length)\r\nKe3 = HKDF-Expand-Label(handshake_secret, \"server enc\", \"\", key_length)\r\n```\r\n\r\n`Km2` is the key used to compute the server's MAC in `KE2`:\r\n\r\n```\r\nKE2 = credential_response, nonceS, info2, epkS, Einfo2, MAC(Km2; transcript2),\r\n```\r\n\r\nUsing the label `\"client mac\"` to derive `Km2` seems backwards. Let's swap them around, like so:\r\n\r\n```\r\nKm2 = HKDF-Expand-Label(handshake_secret, \"server mac\", \"\", Hash.length)\r\nKm3 = HKDF-Expand-Label(handshake_secret, \"client mac\", \"\", Hash.length)\r\nKe2 = HKDF-Expand-Label(handshake_secret, \"server enc\", \"\", key_length)\r\nKe3 = HKDF-Expand-Label(handshake_secret, \"client enc\", \"\", key_length)\r\n```\r\n\r\ncc @hugokraw, @kevinlewi ",
      "createdAt": "2020-10-28T00:47:29Z",
      "updatedAt": "2020-11-02T23:54:07Z",
      "closedAt": "2020-11-02T23:54:06Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Definitely a typo. Good catch.",
          "createdAt": "2020-10-28T15:23:11Z",
          "updatedAt": "2020-10-28T15:23:11Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "MDU6SXNzdWU3MzE0MzgzMjk=",
      "title": "Nail down AKE instantiations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/77",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "TLS 1.3 *is* the SIGMA-I instantiation, so I think we should drop this from the OPAQUE document. It's redundant, and will likely cause confusion between people who want to choose between one or the other. \r\n\r\ncc @kevinlewi ",
      "createdAt": "2020-10-28T13:24:01Z",
      "updatedAt": "2020-12-11T19:36:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't agree with this one. It is important to show that OPAQUE can use any AKE protocol and 3DH/HMQV are of a very special type. In particular, signature-based protocols are always KCI-secure while KEM-based (and \"implicitly authenticated\") are not always. Moreover, if you go by efficiency and you do not want to use HMQV because of the patent, then SIGMA-I is more efficient than 3DH. These are illustrations of the protocol if you want to build it as standalone, not necessarily with TLS. Those building upon TLS are more likely to use the version based on exported authenticators than a 3-flow handshake. \r\nYou can always choose 3DH as the must-to-implement protocol and leave SIGMA-I as optional.",
          "createdAt": "2020-10-28T15:33:17Z",
          "updatedAt": "2020-10-28T15:33:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see any variant in the document as mandatory to implement. I see them as different flavors of AKEs that applications can choose to implement based on their needs. And I think that decision tree should look like the following:\r\n\r\n- If we don't need signatures for authentication, use 3DH (or HMQV)\r\n- If we do need signatures for authentication, use TLS 1.3 with OPAQUE\r\n\r\nCurrently, the decision tree is something like the following:\r\n\r\n- If we don't need signatures for authentication, use 3DH\r\n- If we do need signatures for authentication, use SIGMA-I or TLS 1.3 with OPAQUE. (How do we decide to use TLS 1.3 or SIGMA-I?)\r\n\r\nThe core of this issue is that I don't think it's best to introduce *yet another* AKE with the same shape as TLS 1.3. ",
          "createdAt": "2020-10-28T16:21:09Z",
          "updatedAt": "2020-10-28T16:21:09Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that there is no need to have a must-to-implement version other than for interoperability tests. But I am not sure that someone using a standalone implementation of OPAQUE will necessarily need all the complexities of TLS 1.3 to implement a simple OPAQUE-SIGMA version. An example of a protocol that would favor a signature-based instantiation that is not TLS 1.3 is IKEv2, although they would use SIGMA-R. Yet illustrating SIGMA-I in the document would help that case too.",
          "createdAt": "2020-10-28T16:38:24Z",
          "updatedAt": "2020-10-28T16:38:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "So, as I see it, the delta between OPAQUE-SIGMA-I and TLS 1.3+OPAQUE is the wire format, not much more. If, however, we drop the \"info\" and additional fields (extensions) from OPAQUE-SIGMA-I, then there is a substantial difference. I would be in favor of keeping OPAQUE-SIGMA-I if it dropped extensions, because otherwise it's essentially TLS 1.3 but with a different wire format, and I don't think that rises to the level needed to specify yet another AKE.",
          "createdAt": "2020-10-28T19:11:54Z",
          "updatedAt": "2020-10-28T19:11:54Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not convinced that the complexity of implementing SIGMA-I with the info fields is same as implementing TLS 1.3. It may be the case if you understand the cryptography and system issues of TLS 1.3 well enough to just use the minimal skeleton that serves you in SIGMA-I. But how many such (real) experts are out there? Once we already define the flows for 3DH and HKDF, having them for SIGMA is no big deal. I am not sure that eliminating the SIGMA specific elements makes a huge difference.\r\nAnd I am not sure that we will end defining a flavor of OPAQUE with TLS 1.3 that will use just the three handshake flows (as opposed to defining it with EA and 5 flows).",
          "createdAt": "2020-10-28T22:26:41Z",
          "updatedAt": "2020-10-28T22:26:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It may be the case if you understand the cryptography and system issues of TLS 1.3 well enough to just use the minimal skeleton that serves you in SIGMA-I. But how many such (real) experts are out there? \r\n\r\nThis is my key point: there are probably very few. I don't think it's wise for us to standardize something that the majority of folks may not understand when or how to use when the TLS 1.3 instantiation exists. Moreover, folks who think they can make an informed decision between the two and get it wrong will likely have a bad day. \r\n\r\n> It may be the case if you understand the cryptography and system issues of TLS 1.3 well enough to just use the minimal skeleton that serves you in SIGMA-I. But how many such (real) experts are out there? \r\n\r\nThat's a fair point! If the TLS WG decided to forgo all but the EA flow, then certainly there's a larger difference between SIGMA-I and TLS 1.3+OPAQUE. But if not, I think the delta between these two is small enough that it's not in the CFRG's (or IETF's) best interest to specify.",
          "createdAt": "2020-10-28T22:31:53Z",
          "updatedAt": "2020-10-28T22:33:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(Meta comment: perhaps we should also ask the list and see what they think?)",
          "createdAt": "2020-10-28T22:36:14Z",
          "updatedAt": "2020-10-28T22:36:28Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "It has to be understood that these AKEs are \"informational\"/illustrative, not intended as full specifications. Having the unspecified/optional info fields makes it very clear that we are not providing a full specification. \r\n\r\nI am ok with raising this in the list. ",
          "createdAt": "2020-10-28T22:42:08Z",
          "updatedAt": "2020-10-28T22:42:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It has to be understood that these AKEs are \"informational\"/illustrative, not intended as full specifications. Having the unspecified/optional info fields makes it very clear that we are not providing a full specification.\r\n\r\nAha, well, that's the source of this disagreement! I was approaching this as a complete specification, as that allows us to provide test vectors. If it's incomplete, I'm not sure how we provide test vectors. This definitely seems like something that list should weigh in on. I'll craft a message!",
          "createdAt": "2020-10-28T22:45:41Z",
          "updatedAt": "2020-10-28T22:45:41Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "You can produce test vectors that omit all optional fields. Or you can omit these optional fields from the specification as I just wrote in another thread and say in English that such elements may need to be transmitted by applications but we do not specify them as they will be application specific (we do say that they need to be included in the transcript).",
          "createdAt": "2020-10-28T23:10:12Z",
          "updatedAt": "2020-10-28T23:10:12Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "I saw the message on the list. I don't subscribe, so I'll comment here: a complete OPAQUE-3DH instantiation would be very helpful to me. BTW, the document is getting much easier for me to understand.",
          "createdAt": "2020-12-11T19:36:20Z",
          "updatedAt": "2020-12-11T19:36:20Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWU3Mzc0NDI1MjI=",
      "title": "Use of VOPRF should mention which mode is used",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/79",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Presumably we want to use the VOPRF with modeBase set (as opposed to modeVerifiable). But I could not find this mentioned anywhere in the spec in its current state",
      "createdAt": "2020-11-06T04:12:30Z",
      "updatedAt": "2020-11-09T16:39:34Z",
      "closedAt": "2020-11-09T16:39:34Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, it's the base mode. Do you want to take this and send a PR?",
          "createdAt": "2020-11-06T20:31:46Z",
          "updatedAt": "2020-11-06T20:31:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #80. Closing.",
          "createdAt": "2020-11-09T16:39:34Z",
          "updatedAt": "2020-11-09T16:39:34Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWU3NDAzNjA3NDQ=",
      "title": "Add core OPAQUE protocol test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/82",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "These would omit the AKE integration pieces, since the wire format for that's still unclear.",
      "createdAt": "2020-11-11T00:49:17Z",
      "updatedAt": "2020-11-11T00:49:17Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWU3NDMyNTE5NzE=",
      "title": "XOR-based encryption for Ke2 and Ke3 encryption keys in AKE?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/83",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From [the definition of Ke2 and Ke3](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1071-L1075), the encryption keys used to encrypt the optional Einfo parameters in the AKE section, it seems like the application would need to pick an encryption algorithm for OPAQUE to use here.\r\n\r\nCan we avoid this selection and simply use an XOR-based one-time pad for encryption here (is this secure)? Thus, instead of setting key_length to be a fixed constant, it would simply be the length of Einfo2 and Einfo3.",
      "createdAt": "2020-11-15T13:00:20Z",
      "updatedAt": "2020-12-21T16:46:59Z",
      "closedAt": "2020-12-21T16:46:58Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw ^",
          "createdAt": "2020-11-15T21:51:22Z",
          "updatedAt": "2020-11-15T21:51:22Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The encryption needs to be authenticated-encryption. One could make the point that because the transcript is mac-ed anyway (currently specified only for 3DH/HMQV), then IND-CPA encryption could be enough, hence also xor.  However, I am always wary of such indirect assurances, i.e., using one element in the protocol (the MAC in this case) for two different reasons. The concern is that in the future, one of the reasons may not be relevant any more (because of some other change in the protocol or its requirements) and people will forget it was needed for another reason. A  good example is SIGMA. We could define that the whole transcript not only is signed but also MACed. Then you could use xor for encryption. But since SIGMA does not really need MACing the transcript then eventually the protocol could be simplified by only MACing the identity forgetting that the MAC also server to implement authenticated encryption. And given that GCM is so widespread now, it would be simpler to specify the encryption as GCM.\r\nImportant: Do you want to have a full specification for one of these protocols, say 3DH, at the level of allowing interoperable implementations? In that case we really need to make some choices for instantiating these functions.",
          "createdAt": "2020-11-16T20:30:26Z",
          "updatedAt": "2020-11-16T20:30:26Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the points. I think the only worry I have with specifying the encryption in this manner is that it brings additional complexity into the protocol, despite not being required for the core OPAQUE functionality. But overall I am supportive of it.\r\n\r\nI'm interested to hear what @chris-wood has to say on doing a full spec for one of the AKE protocols.",
          "createdAt": "2020-11-16T20:59:20Z",
          "updatedAt": "2020-11-16T20:59:20Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I was thinking about this and we do need to have a **simple**, full instantiation of OPAQUE to be used for interoperability testing but also for whoever wants a simple aPAKE with the benefits of OPAQUE. I assume that the modularity of design and specification has some important benefits (e.g., making it easier to integrate with existing AKE protocols such as TLS or IKE) but it may also obscure the simplicity of OPAQUE (e.g, when implemented with 3DH).  We should not let people conclude, erroneously,  that OPAQUE is too complex.",
          "createdAt": "2020-11-18T22:16:17Z",
          "updatedAt": "2020-11-18T22:16:17Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Is your conclusion that we could still opt for a simple XOR-based encryption scheme here (since the transcript is already mac-ed), and that we could leave a clear note in the specification stating why XOR-based encryption is OK and what would need to change if the transcript were no longer to be mac-ed?",
          "createdAt": "2020-11-18T23:14:15Z",
          "updatedAt": "2020-11-18T23:14:15Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. That works. I am not sure what would be considered simpler by implementers: encryption implemented by XOR-ing with a bit stream output by HKDF or a call to GCM with a key output by HKDF. Your call, guys.",
          "createdAt": "2020-11-19T02:59:47Z",
          "updatedAt": "2020-11-19T02:59:47Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ^",
          "createdAt": "2020-11-23T03:03:26Z",
          "updatedAt": "2020-11-23T03:03:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's probably easiest to stick with normal AEADs for AKE encryption, though note that this really depends on #77 (or more generally AKE specificity). For example, if we go with the \"this document just specifies templates for *actual* AKEs,\" then any future document describing a *specific* AKE with its wire format would deal with this encryption. But if we decide to specify a *specific* AKE in this document, then we'd have to deal with it.\r\n\r\nI lean towards being specific in this document, rather than punting to implementers and future document authors. (It seems wrong to deliver a partially baked protocol in the standard.)",
          "createdAt": "2020-11-24T01:48:39Z",
          "updatedAt": "2020-11-24T01:48:39Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we are in agreement to have one full specification that includes the AKE part. Now we \"just\" need to agree on the details and choices, including which of the three AKEs in the document - HMQV is the most efficient but it is out for IP reasons :-(",
          "createdAt": "2020-11-24T18:52:21Z",
          "updatedAt": "2020-11-24T18:52:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "My vote would be 3DH. This would allow us to then sketch HMQV and SIGMA-I variants (sort of as we do now). ",
          "createdAt": "2020-11-25T14:34:59Z",
          "updatedAt": "2020-11-25T14:34:59Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me.",
          "createdAt": "2020-11-25T20:24:29Z",
          "updatedAt": "2020-11-25T20:24:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing to track a complete 3DH instantiation in #77.",
          "createdAt": "2020-12-21T16:46:58Z",
          "updatedAt": "2020-12-21T16:46:58Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWU3NDM5MjA4NzQ=",
      "title": "note regarding omitting skU from envelope and deriving it from rwd instead",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/84",
      "state": "OPEN",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in the source there's a commented out part `## Envelope considerations` which mentions that not even `skU` needs to be included in the credentials wrapped in the envelope, instead skU can be derived from `rwd`. there's a note that this part should be \"brought back after updating\". if this is indeed the case, do not forget to change \r\n> Applications MUST include skU in secret_credentials\r\nin the {#protocol-messages} section.",
      "createdAt": "2020-11-16T15:18:02Z",
      "updatedAt": "2020-12-06T12:45:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, we need to remove that commented out text. I'll file a PR for that.",
          "createdAt": "2020-11-16T20:22:20Z",
          "updatedAt": "2020-11-16T20:22:20Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "why do you want to remove it instead of bringing it back? i think this part makes sense.",
          "createdAt": "2020-11-16T21:27:23Z",
          "updatedAt": "2020-11-16T21:27:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> i think this part makes sense.\r\n\r\nI need to think about this more, though my sense is that the bandwidth saved is not worth the additional complexity. The original I-D had this to say about the issue:\r\n\r\n```\r\n   Note (storage/communication efficient EnvU): It is possible to\r\n   shorten EnvU by including PubS in ClrEnv and omitting SecEnv and any\r\n   other value from EnvU.  In this case, the user's key PrivU is derived\r\n   from RwdU; e.g., the value PAD in KEYS is used as a seed for a key\r\n   generation procedure that outputs PrivU (the length of PAD will\r\n   depend on the specific key generation procedure).  Such EnvU consists\r\n   of Nonce, PubS and the HMAC value, resulting in less storage at the\r\n   server and less communication from server to client.  The server can\r\n   further minimize storage space by deriving per-user OPRF keys kU from\r\n   a single global secret key using a PRF, and it can use the same pair\r\n   (PrivS,PubS) for all its users.  In this case, the per-user OPAQUE\r\n   storage consists of Nonce, PubU and HMAC(Khmac; PubS).  While it may\r\n   be \"tempting\" to omit Nonce for space savings, this can lead to\r\n   vulnerabilities (see below).\r\n```\r\n\r\n@hugokraw, what do you think?",
          "createdAt": "2020-12-02T02:22:22Z",
          "updatedAt": "2020-12-03T05:07:14Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am sure that there are cases where such a savings will be meaningful and I am sure it will not be the typical case; I can't say much more than that. Frankly, the main reason I wanted to \"document\" this option is that in Bjorn Hasse's AuCPace paper, the amount of storage and/or communication was the only aspect on which AuCPace had some performance advantage. That paper compared against a very wasteful interpretation of what OPAQUE needed and I wanted to document the fact that one can actually be very minimal in envelope's size. I would prefer to make progress with the specification without entering this level of optimization but if there are potential users of OPAQUE for which these savings are important we could at least leave it as a remark. ",
          "createdAt": "2020-12-03T04:47:30Z",
          "updatedAt": "2020-12-03T04:47:30Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there a systematic / standardized way to generate a private key from a sequence of random bytes (RwdU), for all of the keypair types that we want to support?\r\n\r\nIf so, then I think it would be great to incorporate this optimization into our specification, especially since this will affect how test vectors are generated.\r\n\r\nIf not, then I think we are better off not addressing this optimization, unless there are compelling reasons for practictioners to minimize the extra 32 bytes that are being used for encoding skU.",
          "createdAt": "2020-12-04T01:09:01Z",
          "updatedAt": "2020-12-04T01:09:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is there a systematic / standardized way to generate a private key from a sequence of random bytes (RwdU), for all of the keypair types that we want to support?\r\n\r\nIt depends on the key pair. HPKE [defines specifies a couple derivation functions](https://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#name-derivekeypair) for popular groups. But this isn't exhaustive. Right now, I'm leaning towards not including this optimization, but perhaps this is also something we should bring up to the list. ",
          "createdAt": "2020-12-04T01:15:21Z",
          "updatedAt": "2020-12-04T01:15:21Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is there a systematic / standardized way to generate a private key from a sequence of random bytes (RwdU), for all of the keypair types that we want to support?\r\n\r\nThe universal way is to assume that the key generation procedure works on a string of random bits as input and therefore you can always produce that number of bits out of the RO applied to rwdU. This is simple for the case of EC keys but would not be so simple for an RSA private key (which requires sampling prime numbers).",
          "createdAt": "2020-12-05T18:07:22Z",
          "updatedAt": "2020-12-05T18:07:22Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Hello,\r\n\r\ncan't rwdu be used as input to h2c's HashToScalar and serve as a private key? (This is how I understood OPAQUE the first time I read about it - as an alternative to a secret key used for the envelope)",
          "createdAt": "2020-12-06T01:26:05Z",
          "updatedAt": "2020-12-06T12:45:21Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "MDU6SXNzdWU3NDM5MjY0NzY=",
      "title": "protocol messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/85",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in the specification there is a part which defines `{#protocol-messages}`:\r\n```\r\nenum {\r\n    registration_request(1),\r\n    registration_response(2),\r\n    registration_upload(3),\r\n    credential_request(4),\r\n    credential_response(5),\r\n    (255)\r\n} ProtocolMessageType;\r\n\r\nstruct {\r\n    ProtocolMessageType msg_type;    /* protocol message type */\r\n    uint24 length;                   /* remaining bytes in message */\r\n    select (ProtocolMessage.msg_type) {\r\n        case registration_request: RegistrationRequest;\r\n        case registration_response: RegistrationResponse;\r\n        case registration_upload: RegistrationUpload;\r\n        case credential_request: CredentialRequest;\r\n        case credential_response: CredentialResponse;\r\n    };\r\n} ProtocolMessage;\r\n```\r\nin our implementation at https://github.com/stef/libopaque we omitted implementing this, for the following reasons:\r\n  * this is depending on how an application is using this protocol,  it might not be necessary to wrap protocol messages in such frames, for example because the app already has it's own framing, or different ways to communicate this.\r\n  * parsing any kind of input from possible adversaries should be done higher up the stack, where possibilities are richer to do so in memory safe ways or by implementing language security mechanisms to do so.\r\n\r\nlibopaque does however implement the credential and envelope structures.",
      "createdAt": "2020-11-16T15:24:55Z",
      "updatedAt": "2020-11-16T20:31:55Z",
      "closedAt": "2020-11-16T20:31:55Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, as you point out, this isn't strictly necessary to implement OPAQUE, so we ought to remove it from the spec. @kevinlewi, objections?",
          "createdAt": "2020-11-16T20:16:39Z",
          "updatedAt": "2020-11-16T20:16:52Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am all for removing this!",
          "createdAt": "2020-11-16T20:17:29Z",
          "updatedAt": "2020-11-16T20:17:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Great! See #86 for the change.",
          "createdAt": "2020-11-16T20:26:35Z",
          "updatedAt": "2020-11-16T20:26:35Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWU3NDgwNDc4ODI=",
      "title": "credential_lists in CreateRegistrationResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/87",
      "state": "OPEN",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in this section https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#registration-messages\r\n\r\n```\r\nstruct {\r\n    opaque data<0..2^16-1>;\r\n    opaque pkS<0..2^16-1>;\r\n    CredentialType secret_types<1..255>;\r\n    CredentialType cleartext_types<0..255>;\r\n} RegistrationResponse;\r\n```\r\nSpecifies\r\n\r\n> - secret_credentials_list, a list of CredentialType values clients should include in the secret_credentials list of their Credentials structure\r\n> - cleartext_credentials_list, a list of CredentialType values clients should include in the cleartext_credentials list of their Credentials structure\r\n\r\nwhat if a CredentialType is in both of these lists? Why not pack this information in 10 bits, where each CredentialType has 2 bits for signalling:\r\n```c\r\n  NotPackaged = 0,  // field is not packaged in envelope\r\n  InSecEnv = 1,        // field is encrypted\r\n  InClrEnv = 2          // field is plaintext, but authenticated\r\n```",
      "createdAt": "2020-11-21T16:07:33Z",
      "updatedAt": "2020-11-24T01:43:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "depending on #84 being removed or reinstated, its also interesting what happens if `skU` is included in clearttext_types. especially if #84 removes the commented out section it also means that the whole information with 2bits per CredentialType would even fit into only one byte, assuming that `skU` is mandatory to be included in secret_types\r\n  ",
          "createdAt": "2020-11-21T16:29:41Z",
          "updatedAt": "2020-11-21T16:29:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> what if a CredentialType is in both of these lists\r\n\r\nA credential should only be in one or the other. (We should add text saying that doing otherwise is a protocol violation. I certainly don't see a reason for it, at least.) We can address #84 separately.",
          "createdAt": "2020-11-24T01:43:29Z",
          "updatedAt": "2020-11-24T01:43:29Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU3NDgwNDk5NTc=",
      "title": "id missing in CredentialRequest",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/88",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in the section https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#authenticated-key-exchange-messages CredentialRequest is defined as:\r\n\r\n```\r\nstruct {\r\n    opaque data<1..2^16-1>;\r\n} CredentialRequest;\r\n```\r\nand right below that is this line:\r\n> data : An encoded element in the OPRF group. See {{I-D.irtf-cfrg-voprf}} for a description of this encoding.\r\nand in the https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#createcredentialresponserequest section it is even referred to as:\r\n```\r\n1. (kU, envU, pkU) = LookupUserRecord(request.id)\r\n```\r\n\r\neven though trivial, it might make sense to include id in the CredentialRequest structure definition.",
      "createdAt": "2020-11-21T16:17:43Z",
      "updatedAt": "2020-12-02T03:15:07Z",
      "closedAt": "2020-12-02T03:15:07Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See #65 for the prior discussion on the removal of the id parameter from CredentialRequest.\r\n\r\nMy interpretation of the `LookupUserRecord(request.id)` portion is that it is meant for the wrapper protocol to perform the lookup, so that those details are not kept as part of the OPAQUE protocol.\r\n\r\n@chris-wood Thoughts on this / perhaps editing the text to make it more clear that OPAQUE doesn't handle lookup and doesn't manage the id in its CredentialRequest message?",
          "createdAt": "2020-11-23T03:06:33Z",
          "updatedAt": "2020-11-23T03:06:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That referenced line in the text is a bug (it should have been removed). I'm definitely supportive of clarifying the text to make it clear that identity selection and transfer between client and server is not part of OPAQUE's job. @kevinlewi, will you have time to make a PR for this?",
          "createdAt": "2020-11-24T01:41:25Z",
          "updatedAt": "2020-11-24T01:41:25Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "MDU6SXNzdWU3NDgxMDk1Mzg=",
      "title": "rename StoreUserRecord to indicating the finalization instead of optional persistence",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/89",
      "state": "OPEN",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Just as we dropped the ProtocolMessages part, for the protocol it might be not necessary to call the function StoreUserRecord. For instance my implementation does not care about any kind of persistence or transport of the outcome of the protocol. It might be that the use-case does not need the storage of the user record, for example by just keeping it in memory, or the record might be further processed before storage. Thus i propose to rename the function to `FinalizeUserRecord` instead.",
      "createdAt": "2020-11-21T21:50:54Z",
      "updatedAt": "2020-12-10T10:54:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good suggestion! Like the wrapping protocol message frames, this also isn't strictly necessary. I'll take a stab at removing this text.",
          "createdAt": "2020-11-24T01:44:08Z",
          "updatedAt": "2020-11-24T01:44:08Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "well actually the function itself is kind of necessary. it adds at least the OPRF key to the record, but possibly also a per-user skS. the result is a record to be stored or persisted or whatever. the point is, that it is not really about storage of the record, but about adding the server secrets to it, that are user-specific.",
          "createdAt": "2020-11-24T02:11:51Z",
          "updatedAt": "2020-11-24T02:11:51Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Somewhat unrelated question, but:\r\n\r\nShould this specification define a format for the serialized version of the \"finalized object\" containing (envU, pkS, skS, pkU, kU)? Something like:\r\n```\r\nCredentialRecord {\r\n  opaque envU<1..2^16-1>;\r\n  opaque kU<1..2^16-1>;\r\n  opaque pkU<1..2^16-1>;\r\n}\r\n```\r\n\r\nAnd actually pkS does not need to be stored here, because it is already a part of the credentials object, via:\r\n\r\n\"Applications MUST include skU in secret_credentials and pkS in either cleartext_credentials or secret_credentials.\"\r\n\r\nAnd we likely do not want to advocate for storing skS somewhere like this, so we can retain/amend the comment:\r\n\r\n\"If skS and pkS are used for multiple users, the server can store these values separately and omit them from the user's record.\"",
          "createdAt": "2020-12-02T02:23:10Z",
          "updatedAt": "2020-12-02T02:23:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Great question, @kevinlewi. Over in HPKE we chose to not specify storage wire formats, since they were primarily an implementation detail. That came back to haunt us when we needed to send serialized HPKE contexts between processes. So my sense is that this might be useful if we anticipate a use case where we would need to move these records around between different OPAQUE implementations. Otherwise, I think we ought to leave it to the wrapper protocol and application. ",
          "createdAt": "2020-12-02T03:14:32Z",
          "updatedAt": "2020-12-02T03:14:32Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it would be something that OPAQUE implementations would have to implement, and not leave to their wrapper protocols, since: what is a wrapper protocol expected to do with envU, kU, pkU other than treat them as raw bytestrings that should be serialized in some format?\r\n\r\nSo, if it's likely the case that OPAQUE protocols will be implementing the serialization in their own manner, I think it would be nice if we define a standard way to organize envU, kU, pkU. But this does raise other questions... should we include a version byte in this serialization?",
          "createdAt": "2020-12-03T03:52:57Z",
          "updatedAt": "2020-12-03T03:53:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> what is a wrapper protocol expected to do with envU, kU, pkU other than treat them as raw bytestrings that should be serialized in some format?\r\n\r\nIf these were serialized and minted by implementation A, then implementation A would presumably know how to parse them. I think this is useful only if, for example, implementation A mints the records and implementation B consumes them. I could see that happening in practice if, e.g., the registration and login phases were two separate processes running different implementations, wherein the registration process minted CredentialRecords and then the login process consumed them. If you think arrangements like this are likely, I see no harm in adding something like CredentialRecord.\r\n\r\nAs for serialization: yes, we should definitely version them. I'd just stick in the same version used for the protocol version, e.g.:\r\n\r\n~~~\r\nstruct {\r\n   uint16 version;\r\n   uint16 length;\r\n   select (0xff00) { // version 00 for the draft, or whatever\r\n      // information about the configuration, e.g., OPRF suite and so on, since that determines kU's encoding \r\n      Envelope envU;\r\n      Scalar kU;\r\n      opaque pkU<0..2^16-1>;\r\n   }\r\n} CredentialRecord;\r\n~~~",
          "createdAt": "2020-12-03T04:05:17Z",
          "updatedAt": "2020-12-03T04:05:28Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Good points, I see. Yes, I think this scenario could be likely, since registration and login may need to be in different languages (for example).\r\n\r\nThe struct looks good, except -- why do we need a `uint16 length;` field? Seemingly that could be omitted.",
          "createdAt": "2020-12-03T04:18:13Z",
          "updatedAt": "2020-12-03T04:18:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The struct looks good, except -- why do we need a uint16 length; field? Seemingly that could be omitted.\r\n\r\nImagine one added support for two versions of OPAQUE at the same time, yet the login only knows how to process one specific version. Since the contents of the record depend on the version, there needs to be a way for implementations that don't support a given version to skip over records they cannot parse, and the length field does just that. So for example, an implementation would read the version field and, if it's unsupported, skip `length` bytes to the next record in a list, and repeat. ",
          "createdAt": "2020-12-03T04:21:27Z",
          "updatedAt": "2020-12-03T04:21:27Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "This would only be a problem if the wrapper protocol stores these records in a contiguous sequence of bytes with no delimiters for the beginnings of each record, though, right?\r\n\r\nI don't imagine that this would ever occur... but perhaps I'm missing something. At the very least, these records would be stored as values of a map, or elements of an array.",
          "createdAt": "2020-12-03T04:46:12Z",
          "updatedAt": "2020-12-03T04:46:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, that's true! If a wrapper chose to store these in a map from idU -> [records], then perhaps this would be relevant. If it has some other (simpler) way to delineate different records, we can certainly omit the length. \r\n\r\n@kevinlewi, would you mind proposing a PR for the record format?",
          "createdAt": "2020-12-03T05:09:19Z",
          "updatedAt": "2020-12-03T05:09:19Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "i don't know how the hpke storage formats came to haunt you guys, but i would say that since we do not specify protocol message formats, storage formats also do not need to be specified, or if they do, they might be specified in a different rfc, together with wire formats. the question for me, is is this about the cryptographic protocol or the communication/application protocol, and for me, i prefer to stick to the cryptographic protocol only. since the communication/application protocol brings along a lot of stuff as an low level implementer would not like to implement.\r\n\r\ni am also worried about \"variable length\" records, that means complexity, i believe the implementation should know exactly how big a record or any protocol message is, without encoding it in the message. implementing parsing of these things means added complexity, and added complexity means attack surface. it is already worrying that `idU` and `idS` might be free-form strings with random lengths - i would really prefer allowing only uuids/hashes or similar fixed-width strings, that would eliminate variable lengths parsing from fixed configuration setups of opaque.",
          "createdAt": "2020-12-08T17:17:16Z",
          "updatedAt": "2020-12-08T17:17:44Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @stef, thanks for the comments on this, I think you bring up good points.\r\n\r\nI agree that we should stick to only specifying the cryptographic protocol. But, to clarify, aren't we already specifying message / wire formats (e.g. the bytes that consist of a RegistrationRequest) in this RFC? I see this as still being part of the cryptographic protocol. The reason being that we want a wrapper protocol to be able to not have to worry about the internals of the OPAQUE implementation, and if we did not specify the message / wire formats, then it must mean that the wrapper protocol would have to be exposed to the specifics behind kU, rwdU, etc. (which in my opinion is undesirable).\r\n\r\nA similar argument I think can be made for why we may want to specify storage formats for the password file. If we do not, then doesn't this mean that the OPAQUE protocol must expose to the wrapper protocol the individual components that make up the password file (pkU, envU, kU), and we would leave it up to the wrapper protocol to decide what to do with these objects? In my opinion, it would feel cleaner to have the OPAQUE protocol dictate how these objects would be serialized together, so that the wrapper protocol need not have to interpret what each of pkU, envU, and kU mean.\r\n\r\n> i am also worried about \"variable length\" records, that means complexity, i believe the implementation should know exactly how big a record or any protocol message is, without encoding it in the message. implementing parsing of these things means added complexity, and added complexity means attack surface.\r\n\r\nI agree with this -- I think one way in which we might hope to simplify things would be to consider the suggestions I made in #99 regarding the simplification of the envelope construction. However, this would still mean that we have a \"custom identifier\" mode, which does not solve the problem of the variable-length `idU` and `idS`. Perhaps we can draft a separate issue to talk specifically about whether or not would be a good idea to enforce fixed-width strings for `idU` and `idS`.",
          "createdAt": "2020-12-10T10:54:11Z",
          "updatedAt": "2020-12-10T10:54:11Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWU3NDkyOTgxMDU=",
      "title": "Proposal: Completely remove all mention of idU and idS for the sake of simplicity",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/90",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'd like to open a discussion on the following proposal: to **completely remove all mention of idU and idS** from the OPAQUE spec (aside from places where we can refer to it as guidance for an implementor of a wrapper protocol that calls OPAQUE). To be clear, this change would mean that we set idU = pkU and idS = pkS in all locations where idU and idS appear in the current draft (not to completely remove their inclusion from the draft).\r\n\r\n(Note: Past discussion on this issue occurred in #74, spawned from the question of \"Can we simply set idU = static pkU and idS = static pkS?\". This will be a continuation of some of the discussion in that issue.)\r\n\r\nThe current state of the draft suggests that we involve idU and idS in the following places:\r\n1) [As potential parameters which can be supplied to the envelope](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L414-L415) as either secret or cleartext credentials\r\n2) If they are specified in the envelope, then [they must be input as parameters to the AKE login](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1064-L1066) (by at least the server). If they were not specified in the envelope, then pkU and pkS are used in their place. They are then used to affect the [AKE key derivation](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1113-L1114).\r\n3) In the past there have also been discussions around potentially incorporating idU as part of the initial input to the OPRF: namely, instead of doing OPRF(key, password), do something like OPRF(key, HKDF(password, idU)).\r\n\r\n## Proposal\r\n\r\nDefer all mention of idU and idS to the wrapper protocol that calls OPAQUE, do not allow them to be specified in the envelope, and use pkU and pkS in their place within the AKE section.\r\n\r\nFor wrapper protocols that wish to supply an idU and idS which should be protected by the security guarantees of the OPRF, **we should instead recommend these wrapper protocols to take advantage of the [export_key parameter](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L651)** to do custom encryption/authentication for the bindings between idU/pkU and idS/pkS.\r\n\r\n### Pros\r\n\r\n- When we ultimately provide test vectors for OPAQUE, it will of course be simpler to not have to include idU and idS as parameters to the test vector generation.\r\n- Also, the above logic where the server must remember how the envelope was constructed in order to figure out how to set idU and idS is something that I suspect will trip up implementors. At the very least, we would need to produce test vectors which specifically test for these kinds of edge cases (what happens if idU and idS are specified in the envelope, and the server mis-specifies them in AKE, or what if they were not specified in the envelope, but the server tries to specify them, etc.).\r\n\r\nThe advantage to this proposal is that we can remove all of this complexity and potential for errors from the implementation side. The result is that OPAQUE no longer references any application-specific idU and idS parameters, which to me feels much cleaner than our current state where there are many conditionals and optional parameters to check (a nightmare for generating test vectors and verifying that an implementation can support all possible settings bug-free).\r\n\r\n### Cons\r\n\r\nThe main worry for removing idU and idS is the potential for a loss of generality (what if a wrapper protocol wants to tie idU and idS into the OPRF/AKE security guarantees?). I propose that we recommend wrapper protocols to use export_key for this purpose, so the details of idU and idS can remain outside of the OPAQUE protocol. There is still a cost here, because previously we used HKDF(RwdU, ...) to encrypt idU and idS, whereas now they would be using export_key, which would amount to an extra HKDF computation or two. But I think this price is totally worth the simplicity that it brings the OPAQUE protocol, especially since this is a client-side operation, and we are already recommending clients to compute a memory-hard hash function which will be way more expensive.\r\n\r\nAnd finally, to address (3), we should recommend wrapper protocols to pre-hash idU and the password before starting the OPAQUE protocol, again so that we can avoid incorporating the idU parameter within the OPAQUE protocol.\r\n\r\ncc: @hugokraw , @chris-wood ",
      "createdAt": "2020-11-24T02:59:07Z",
      "updatedAt": "2020-11-30T20:51:52Z",
      "closedAt": "2020-11-30T20:51:51Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I strongly oppose this for several reasons. Here are some:  \r\n\r\n> The result is that OPAQUE no longer references any application-specific idU and idS parameters\r\n\r\nOPAQUE is an authenticated key exchange protocol and there is no meaning to authentication without identities. Who you are exchanging a key with is not less important than the secrecy and randomness of the key. As such, OPAQUE must have idU and idS as essential elements, and indeed you cannot derive a key without them. So the only question is who determines these identities and how they are communicated in the protocol. We simplified the treatment by setting defaults (pkU and pkS) and providing a native mechanism to change this in an *authenticated* way if so desired.  If you eliminate the use of the envelope for this transmission of identities you need to either say \"sorry, you can only use pkU and pkS as identities\" (which is too restrictive) or create yet another mechanism for this authenticated transmission. I find this more complex and prone to error than including the id's in the envelope. In particular, the export key is intended for extensions to OPAQUE, not to serve a prime functionality as authenticating identities.  \r\n\r\n> the server must remember how the envelope was constructed\r\n\r\nThe server is the one to set these mechanisms at registration and there is no reason it forgets them. Moreover, the server stores the identities and it never needs to look at the envelope (except as a space optimization in case the identities contained in the envelope are not encrypted).  \r\n\r\n> we should recommend wrapper protocols to pre-hash idU and the password before starting the OPAQUE protocol, again so that we can avoid incorporating the idU parameter within the OPAQUE protocol.\r\n\r\nI would not remove idU from the AKE key derivation even if you included it under the OPRF. It is important to keep the modular composition of OPRF and AKE where each part delivers what is expected from such component. Also, one has to be careful (actually we may want to have a note on this) to avoid any replacement or instantiation of a user's identity with something like H(uid, password). If someone thinks of this as an identity then it is likely to think it does not require secrecy. Of course, if you publish H(id, password) you broke aPAKE completely as you can do an offline attack on the password just given idU.",
          "createdAt": "2020-11-25T21:18:05Z",
          "updatedAt": "2020-11-25T21:18:05Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Hugo, in reading your response, I realize that my original proposal might have been slightly unclear -- I am not advocating for removing idU and idS, but instead advocating for fixing idU = pkU, idS = pkS, and **not allowing** for the wrapper protocol to set idU and idS to anything else. (I will edit the original text to clarify this.) In other words, I am proposing to say:\r\n\r\n>  \"sorry, you can only use pkU and pkS as identities\" (which is too restrictive)\r\n\r\nCan you elaborate a bit more on why this is too restrictive, and why export_key cannot be used in the manner I suggested?\r\n\r\n> In particular, the export key is intended for extensions to OPAQUE, not to serve a prime functionality as authenticating identities.\r\n\r\nI see the use of export_key in my proposal not as authenticating identities, but simply allowing for a binding between the wrapper protocol's understanding of idU, and pkU.\r\n\r\n---\r\n\r\nBy the way, I want to place emphasis on the **simplicity** that I am aiming for with this proposal. I agree that by not allowing for custom idU and idS, we are making it more difficult for a wrapper protocol to get the security benefits of using custom idU and idS. I just want us to be cognizant of the costs that come with the increased complexity of supporting a custom idU and idS. If we come to an agreement that this increased complexity is worth the support for the feature, then we should definitely support it.\r\n\r\nOne way that I see the complexity being increased by supporting custom idU and idS here is the following. Let's say we come across an OPAQUE implementation in the wild. How difficult is it to check whether or not it complies with this specification? How many edge cases does one need to verify with the OPAQUE implementation (adding custom idU, putting idU in the envelope but not reusing it in the AKE section, etc.) in order for the community to be able to confidently say that it is in compliance? At the very least, we would need to provide a set of test vectors which test each edge case. I'd like for us to keep in mind that we do not want the complexity of correctness verification to be too large. Otherwise, we may end up in a situation where we produce a complete specification, but implementations frequently have bugs.",
          "createdAt": "2020-11-25T21:38:39Z",
          "updatedAt": "2020-11-25T22:01:01Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I appreciate any simplification but not enough in this case to \"outsource\" the management of identities outside the protocol. The identities need to be communicated in an authenticated way and I prefer not to trust wrappers or random implementers to take good care of it. Is the complexity we are talking about coming from letting wrappers choose identities that are neither pkU, pkS or those included in the envelope?  Would it be ok if we limit implementations to reduce flexibility of choosing identities to the following line:\r\nIf Envelope.Ids != null  set  IdU=envelope.idU, idS=envelope.idS else set  idU=pkU, idS=pkS\r\nand everywhere else use idU and idS as set in this line?\r\nWould that still leave corner cases?\r\n",
          "createdAt": "2020-11-25T22:54:01Z",
          "updatedAt": "2020-11-25T22:54:01Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is the complexity we are talking about coming from letting wrappers choose identities that are neither pkU, pkS or those included in the envelope?\r\n\r\nNo, I believe that we are already disallowing for this to occur. The identities must be set in the envelope, or if not set, then default to pkU and pkS. So, this is not where the extra complexity would be coming from.\r\n\r\nAfter some more thought on this + your suggestions, @hugokraw, I think I can reduce my concerns down to the following:\r\n1) There is a lot of flexibility in how the envelope is configured. What if the server says that the envelope contains an idU but no idS, or vice versa? We would need to produce test vectors for each possible setting and check that the appropriate behavior occurs in the AKE section, which is quite cumbersome.\r\n2) Setting idU and idS to be the empty string in the envelope is very different from not setting idU and idS in the envelope. I'm worried that implementations will get this wrong, since often the empty string is syntactically similar to \"not being set\", and so we may need to add test vectors to address this as well.\r\n\r\nEssentially both of these issues can be boiled down to reducing the complexity of setting the structure of the envelope. One solution I can think of for addressing this potential ambiguity is to take note from the VOPRF RFC and perhaps define \"modes\" for the envelope, either a \"base mode\" which does not set idU and idS, and a \"custom identifier mode\" which requires idU and idS to be set in the envelope.\r\n\r\nI have some other concerns about the customizability of the envelope, which I plan to create an issue about to address all at once. So I will close out this issue and instead defer further discussion of the above two points to a new issue about simplifying the complexity of the envelope itself.\r\n\r\nThanks for the fruitful discussions -- hope this makes sense!",
          "createdAt": "2020-11-30T20:51:51Z",
          "updatedAt": "2020-11-30T20:51:51Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWU3NTE4Mzg3MTE=",
      "title": "Update to the new VOPRF draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/91",
      "state": "CLOSED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-26T21:44:13Z",
      "updatedAt": "2020-12-01T22:21:45Z",
      "closedAt": "2020-12-01T22:21:45Z",
      "comments": []
    },
    {
      "number": 94,
      "id": "MDU6SXNzdWU3NTU3ODkzNjE=",
      "title": "Remove RequestMetadata type",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/94",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This struct stores the scalar across Request/Finalize calls, which both happen on the client. There's no need to serialize or send this value on the wire anywhere, so we should just defer its representation to the underlying implementation. Given that the OPRF API is already a dependency we expose, I suggest we replace RequestMetadata with the actual type `Scalar`. \r\n\r\nWhile we're in here, we might also consider removing superfluous wrappers around OPRF types (like `RegistrationRequest` and `CredentialRequest`). \r\n\r\n@kevinlewi, what do you think?",
      "createdAt": "2020-12-03T03:42:32Z",
      "updatedAt": "2020-12-03T04:14:20Z",
      "closedAt": "2020-12-03T04:14:20Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me. Just to be clear, none of the changes that you are referencing will actually affect the bytes being output by these functions, right? They are just syntactic changes to clean up the presentation if I am understanding correctly.",
          "createdAt": "2020-12-03T03:48:43Z",
          "updatedAt": "2020-12-03T03:48:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, partly. RequestMetadata contains a vector encoding of a scalar (so a serialized scalar prefixed by its length), but that's not really needed. What I'm suggesting is that we just output a scalar, e.g.:\r\n\r\n```\r\nCreateCredentialRequest(pwdU)\r\n\r\nInput:\r\n- pwdU, an opaque byte string containing the user's password\r\n\r\nOutput:\r\n- request, an CredentialRequest structure\r\n- r, an OPRF Scalar value\r\n\r\nSteps:\r\n1. (r, M) = Blind(pwdU)\r\n2. Create CredentialRequest request with M\r\n3. Output (request, r)\r\n```",
          "createdAt": "2020-12-03T03:52:03Z",
          "updatedAt": "2020-12-03T03:52:03Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, got it. Yes, this makes sense, I believe in my implementation I already omitted the length prefix anyway.",
          "createdAt": "2020-12-03T03:56:13Z",
          "updatedAt": "2020-12-03T03:56:13Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWU3NTY2MTMyNTY=",
      "title": "Envelope correctness",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/96",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The record sent from client to server during the registration phase is as follows:\r\n\r\n~~~\r\nstruct {\r\n    Envelope envelope;\r\n    opaque pkU<0..2^16-1>;\r\n} RegistrationUpload;\r\n~~~\r\n\r\nAs is, the server has no assurance that the private key corresponding to `pkU` is inside (or derived from) the envelope. This raises two questions:\r\n\r\n1) Does the client need to prove possession of `skU`?\r\n2) If so, how would this work (non-interactively) for DH-based public keys? If not, we should probably add text clarifying why this isn't needed.",
      "createdAt": "2020-12-03T21:41:04Z",
      "updatedAt": "2020-12-16T21:08:12Z",
      "closedAt": "2020-12-16T21:08:11Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Although it would be nice if the client could prove possession of `skU`, I don't think it merits the extra complexity / computation that would be required, since I cannot imagine a scenario in which the server would need the assurance that the private key corresponding to `pkU` is inside the envelope. Did you have an example scenario in mind?",
          "createdAt": "2020-12-04T00:44:10Z",
          "updatedAt": "2020-12-04T00:44:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Nothing comes to mind right now, though I haven't given it much thought. ",
          "createdAt": "2020-12-04T01:13:15Z",
          "updatedAt": "2020-12-04T01:13:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's close this for now. We can re-open if needed later on.",
          "createdAt": "2020-12-16T21:08:11Z",
          "updatedAt": "2020-12-16T21:08:11Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWU3NTY3MDY2MTc=",
      "title": "Defining SerializeExtensions and DeserializeExtensions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/97",
      "state": "OPEN",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L444-L446): Don't these functions need to be defined somewhere? At least they should sort the extensions by their type, perhaps in increasing order. It seems defining these in the specification is a requirement to producing compatible test vectors.\r\n\r\ncc: @chris-wood ",
      "createdAt": "2020-12-04T00:53:48Z",
      "updatedAt": "2020-12-04T02:11:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> At least they should sort the extensions by their type, perhaps in increasing order.\r\n\r\nSorting isn't required, since each extension is identified by its type. That said, adding more detail so their implementation is clear wouldn't hurt.",
          "createdAt": "2020-12-04T01:18:04Z",
          "updatedAt": "2020-12-04T01:18:04Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "If one implementation decides to sort the credentials in increasing order, and another decides to sort the credentials in decreasing order, then they will end up with a different HMAC output. Our test vectors will pick some ordering in order to generate the HMAC, and so seemingly this ordering should be spelled out in the specification, right?",
          "createdAt": "2020-12-04T02:07:44Z",
          "updatedAt": "2020-12-04T02:07:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, yeah, good point about different implementations. I\u2019ll draft up a PR for this soon.",
          "createdAt": "2020-12-04T02:11:40Z",
          "updatedAt": "2020-12-04T02:11:40Z"
        }
      ]
    },
    {
      "number": 98,
      "id": "MDU6SXNzdWU3NTY3MDk3ODM=",
      "title": "Removing auth_data from the envelope",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/98",
      "state": "OPEN",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think we should remove the [`auth_data` field](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L455) in the envelope, but still keep it as part of the [HMAC derivation process](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L639-L641). The only reason why this might be set is if it contains a credential that is marked as a member of cleartext_credentials. But in this case, why not just make it a secret_credentials instead?\r\n\r\nThe advantage of cleartext_credentials are only apparent when the credential itself is NOT included in auth_data (and hence does not affect the total size of the envelope).",
      "createdAt": "2020-12-04T01:02:09Z",
      "updatedAt": "2020-12-10T22:20:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is a fine idea, but we still need a way for the client to know what values to include in the HMAC computation. Would the server supply, in its CredentialResponse, the list of cleartext_credential types used?",
          "createdAt": "2020-12-10T22:20:19Z",
          "updatedAt": "2020-12-10T22:20:19Z"
        }
      ]
    },
    {
      "number": 99,
      "id": "MDU6SXNzdWU3NTY3MTMzMjc=",
      "title": "Simplifying the options for the credentials list in the envelope",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/99",
      "state": "OPEN",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This issue is related to #87 and #90, in which the complexities of the setting of the envelope have come up.\r\n\r\nOne problem I foresee happening with allowing the server to choose what parameters should be optional, [which go in secret_credentials, which go in cleartext_credentials, etc.](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L438-L442) is that it becomes cumbersome to manage exhaustive test vectors that would test all of the edge cases (combinations of these settings). And if we choose to only provide test vectors for some default setting, we run the risk of an implementation in the wild incorrectly implementing support for a non-default setting that we did not provide test vectors for.\r\n\r\nTo remedy this, one approach we could take would be to allow for only a small (maybe 2?) set of options for organizing the credentials in the envelope. Perhaps a \"base mode\" and a \"custom identifier mode\", and we could spend a single byte to dictate the mode for the envelope (similar to the VOPRF RFC with the byte representing the base mode or verifiable mode). Base mode would be some default, and \"custom identifier mode\" would support a custom idU and idS being included as secret_credentials.\r\n\r\nIf this sounds good, then now we just need to decide what modes we will support, and what each mode will look like.\r\n",
      "createdAt": "2020-12-04T01:10:53Z",
      "updatedAt": "2020-12-23T11:18:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this idea. Given that the number of credential types is likely quite small, I'm in favor of simplifying things and offering two modes here. For the \"custom identifier mode,\" either idU or idS could be nil, if desired, right? Or would we require that they both non-nil?",
          "createdAt": "2020-12-10T22:17:59Z",
          "updatedAt": "2020-12-10T22:17:59Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should allow for nil idU and idS, because it is not easy to check/enforce that idU and idS, and even if it were easily checkable, it is still an additional check that the OPAQUE implementation would have to do, which increases complexity.",
          "createdAt": "2020-12-10T22:42:11Z",
          "updatedAt": "2020-12-10T22:42:11Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Both idu and ids are used in the \"info\" / \"transcript\" (naming is not consistent) parameter in HKDF. Having them _nillable_ means the HKDF only relies on the nonces. I don't know if that's a problem.\r\n\r\nMoreover, both idu and ids are used in Sigma.",
          "createdAt": "2020-12-23T10:23:23Z",
          "updatedAt": "2020-12-23T11:18:41Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWU3NjEyNTY1MDI=",
      "title": "export_keys also need AE with RKR",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/100",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "since my implementation has been prominently featured in the \"partitioning oracles paper\" i was thinking that the export_key must also only be used with key-committing AE schemes. i think this should be emphasized where export_keys are mentioned in the draft.",
      "createdAt": "2020-12-10T13:48:07Z",
      "updatedAt": "2020-12-21T16:42:15Z",
      "closedAt": "2020-12-21T16:42:15Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, this is an interesting point. @hugokraw, are there key-committing restrictions for the export key in terms of how it can be used by applications?",
          "createdAt": "2020-12-16T21:24:14Z",
          "updatedAt": "2020-12-16T21:24:14Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a good question but the answer is no. The export key has no special restrictions except for the remark in the {#export-usage} section: _The exporter_key MUST NOT be used in any way before the HMAC value in the envelope is validated._",
          "createdAt": "2020-12-16T21:56:48Z",
          "updatedAt": "2020-12-16T21:56:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! I'll draft a PR that notes this in the Security Considerations.",
          "createdAt": "2020-12-17T01:59:43Z",
          "updatedAt": "2020-12-17T01:59:43Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "This needs to be merged with PR 101 - see comment there.",
          "createdAt": "2020-12-17T06:23:03Z",
          "updatedAt": "2020-12-17T06:23:03Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWU3NzMyOTUxNDE=",
      "title": "Sigma-I signature algorithm specification",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/103",
      "state": "OPEN",
      "author": "bytemare",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\n\r\nSigma uses signatures, for which no algorithm has been specified in the current draft.\r\n\r\nsku/pku can be generated and used independently from the ciphersuite used in the rest of the protocol and stored in the envelope. This would introduce one more parameter, and for Sigma only, if OPAQUE allows for that kind flexibility. From what I understand, the number of parameters is already a concern.\r\n\r\nHow should the Sigma signature algorithm be set or chosen ?",
      "createdAt": "2020-12-22T22:39:11Z",
      "updatedAt": "2020-12-22T22:39:11Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWU3NzM3MDYyMTU=",
      "title": "Specify group for AKE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/104",
      "state": "OPEN",
      "author": "bytemare",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The current draft does not specify what groups can or should be used for the AKE. I first thought it was the same as for the OPRF.\r\n\r\nShould the group for the AKE be the same as for the OPRF, or is an additional parameter necessary?",
      "createdAt": "2020-12-23T12:03:22Z",
      "updatedAt": "2020-12-23T12:03:22Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWU3NzQ2MTE0ODI=",
      "title": "Update wrapper protocol APIs to pass in credentials to FinalizeRequest",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/105",
      "state": "OPEN",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Following up on the comment above, we might simplify things by delegating the \"credential construction\" logic to the wrapper protocol, which (a) knows the mode and (b) has the relevant information (skU, idU, pkS, idS, etc). That would make the interface to `FinalizeRequest` something like so:\r\n\r\n```\r\nFinalizeRequest(pwdU, creds, blind, response)\r\n```\r\n\r\nWhere `creds` contains the `secret_credentials` and `cleartext_credentials`, already in wire format form, to use when creating the envelope.\r\n\r\n_Originally posted by @chris-wood in https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/102#issuecomment-749720379_",
      "createdAt": "2020-12-25T03:13:54Z",
      "updatedAt": "2020-12-25T03:13:54Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5NTMwNTY4",
      "title": "Cleanup the document.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/1",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-18T14:14:15Z",
      "updatedAt": "2020-05-18T14:14:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "141e15efee0a73c14ce1d9766c591e7fd974dba9",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/cleanup",
      "headRefOid": "1f060a625d001ec1e9ba4cfcc1ba25c23a8b7742",
      "closedAt": "2020-05-18T14:14:21Z",
      "mergedAt": "2020-05-18T14:14:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3b004d0e822b3bdb0d3e2c42eefcadf4c1c5c0c6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMjMzOTc1",
      "title": "Fixed typo in K3dh definition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/10",
      "state": "MERGED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #8",
      "createdAt": "2020-05-19T16:34:15Z",
      "updatedAt": "2020-05-19T16:43:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "3b004d0e822b3bdb0d3e2c42eefcadf4c1c5c0c6",
      "headRepository": "hugokraw/draft-irtf-cfrg-opaque",
      "headRefName": "patch-1",
      "headRefOid": "5a5d843c37034a6bddab4de46951382be9761480",
      "closedAt": "2020-05-19T16:43:28Z",
      "mergedAt": "2020-05-19T16:43:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e73d7287709206ea755e23e6369e989b16bea940"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjMzMzE3",
          "commit": {
            "abbreviatedOid": "5a5d843"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-19T16:43:22Z",
          "updatedAt": "2020-05-19T16:43:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMjQxNTk0",
      "title": "Minor fix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/11",
      "state": "MERGED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-19T16:48:47Z",
      "updatedAt": "2020-05-19T17:02:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e73d7287709206ea755e23e6369e989b16bea940",
      "headRepository": "hugokraw/draft-irtf-cfrg-opaque",
      "headRefName": "patch-1",
      "headRefOid": "0d9b5d801cf2d87dd7d6e575a75780acf174457f",
      "closedAt": "2020-05-19T17:02:19Z",
      "mergedAt": "2020-05-19T17:02:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "64e188b1197d555f14a4358bde2d9541b056b956"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjQ4MzUz",
          "commit": {
            "abbreviatedOid": "0d9b5d8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-19T17:02:13Z",
          "updatedAt": "2020-05-19T17:02:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxMTIyMjUw",
      "title": "Apply Hugo's changes.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/12",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @hugokraw ",
      "createdAt": "2020-05-21T03:04:11Z",
      "updatedAt": "2020-05-21T13:24:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "64e188b1197d555f14a4358bde2d9541b056b956",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hugo-branch",
      "headRefOid": "5514ae0638c28572bc0ea06dfbbaf0a8ca71591e",
      "closedAt": "2020-05-21T13:24:21Z",
      "mergedAt": "2020-05-21T13:24:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9cef30edba1afce5701546450fa5be004e87fdd5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxNDUwODQ5",
      "title": "Add self as an author.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/13",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-21T16:25:28Z",
      "updatedAt": "2020-05-21T21:32:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "9cef30edba1afce5701546450fa5be004e87fdd5",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/author",
      "headRefOid": "5a7be151b0db2b30242c4973bcfa13b24fe170ce",
      "closedAt": "2020-05-21T21:32:59Z",
      "mergedAt": "2020-05-21T21:32:58Z",
      "mergedBy": "hugokraw",
      "mergeCommit": {
        "oid": "1a45065d3f8ef7617093b9e36d874a20f5d5a2ca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTA4MjU2",
          "commit": {
            "abbreviatedOid": "5a7be15"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Welcome Chris :-)",
          "createdAt": "2020-05-21T21:31:57Z",
          "updatedAt": "2020-05-21T21:31:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxNDUyNDc3",
      "title": "Address Eric's comments.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/14",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #9.",
      "createdAt": "2020-05-21T16:28:33Z",
      "updatedAt": "2020-05-21T21:27:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "9cef30edba1afce5701546450fa5be004e87fdd5",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/eric-comments",
      "headRefOid": "39be24df302cfce0bcc0ef9d66d4281ab1fd5ef8",
      "closedAt": "2020-05-21T21:27:52Z",
      "mergedAt": "2020-05-21T21:27:52Z",
      "mergedBy": "hugokraw",
      "mergeCommit": {
        "oid": "5bbe4a7e6e1b3938dd78ebe25470246301cf0418"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTA1MTE4",
          "commit": {
            "abbreviatedOid": "39be24d"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm good with #14 resolution (Eric comments)",
          "createdAt": "2020-05-21T21:27:22Z",
          "updatedAt": "2020-05-21T21:27:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIyMjg1MzU1",
      "title": "Initial draft of wire format messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change shuffles around content and replaces the text-based protocol descriptions with protocol flows and messages. It also includes a first cut at wire format details for these messages. (We can always iterate later on!) \r\n\r\ncc @hugokraw \r\n",
      "createdAt": "2020-05-23T14:58:59Z",
      "updatedAt": "2020-05-28T12:32:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "1a45065d3f8ef7617093b9e36d874a20f5d5a2ca",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/wire-formats",
      "headRefOid": "f9e7f430da7a35fcf3ec751927d31edcd9f0185a",
      "closedAt": "2020-05-28T12:32:08Z",
      "mergedAt": "2020-05-28T12:32:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "21de69f0b70488207df108cd25023ed421be24df"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Chris, I went over the specification text. Looks good (and a lot of\nwork).\nThanks!\n\nI have several comments. I was not sure how to better communicate this in\nthe\ngithub so pardon the use of 20th century technology here...\n\nComments are mostly in the order of appearance in the document, not by\norder of\nimportance.\n\n-- You say:\n> Client (U): Entity which has knowledge of a password and wishes to\nauthenticate.\nHere and in other places, including the naming of the online phase as the\n\"authentication\" phase, make this seem as just authentication when it is\nalso\nkey exchange. I have this note in the draft saying that authentication\nwithout\nkey exchange is \"analogous to carefully checking a visitor's credential at\nthe door and then leaving the door open for others to enter freely.\"\n\n-- The expression \"group key pair\" was unclear/confusing to me.\n\n-- Somewhere you say: \"Where noted, random choices can be replaced with\nfresh\noutputs from a cryptographically strong pseudorandom generator or\npseudorandom\nfunction.\"\n\nThe default is that we can replace randomness with pseudorandomness; we\nshould\nnote the cases where this is not the case and not the cases where\nreplacement is\nfine (essentially all cases).\n\n-- VOPRF: We never use the verifiability property; it would violate the\nPKI-freeness. We can use g^kU for fixed-base blinding but g^kU in this case\nis\nnot certified, just sent from server to client (possibly cached by the\nlatter)\n\n-- Fixed-base blinding: You are defining the OPRF with var-base blinding,\nnot\nleaving the option of fixed-base blinding (which would need to transfer\ng^kU).\n\n-- Generic OPRF vs DH-OPRF: This issue of blinding mechanisms points to the\nfact\nthat while all components of the protocol are generic in your\nspecification, the\nOPRF is fixed to DH-OPRF. I do not suggest complicating presentation too\nmuch\njust for the sake of being generic but I would definitely want to allow an\noptimization such as fixed-base blinding, and this may call for a more\ngeneral\nAPI (e.g., an OPRF structure with Request/Response).\n\n-- From the expression Open(k, n, aad, ct) I understand that you do not see\naad\nas part of ct. Is this right?\n\n-- In the OPRF ciphersuites there is no 256-bit curve. Why is that?\nIn the case of integration with TLS wouldn't we be using the curves TLS\nuses?\n\n-- In the hardening functions, shouldn't one allow for PBKDF for backward\ncompatibility reasons? I know of some company that wanted that exactly for\nthat\nreason.\n\n-- The Credentials structure: Setting it to the 4 elements as you define is\nfine\nand should cover common cases. However, pkU is usually not needed by the\nclient\n(that's the case for all the AKE examples I considered) so it may be\nremoved.\nThe public key pkS need not be encrypted but I assume we don't gain much by\nnot\nencrypting it. Do you mean to always encrypt all elements? And if so, why is\nthere a AAD field?\n\nI know we do not want to leave too many options but I would not want to\nprohibit\nthe encryption-less case where you only send the authenticated pkS (skS is\nderived from RwdU). The only place where I saw some benefit in AuCPace is\nthat\nthey had less bits in the wire. OPAQUE with the encryption-less option beats\nthem in that sense too. This mode also removes the annoying equivocable\nencryption property that we need in the UC analysis.\n\n--  When specifying the envelope encryption, I defined an optional key KdKey\nderived from RwdU for extended functionalities, e.g., as a way to retrieve\nnon-OPAQUE credentials (or to support the encryption-less option). We will\nsee\nhow we go about specifying the envelope encryption and then see what\nhappens to\nsuch KdKey.\n\n-- RwdU = Harden(y): This function should accept hardness parameters (or you\nassume they are part of the function definition)\n\n-- The name OPAQUE collides with \"opaque\" as an object type. Maybe say at\nthe\nbeginning that the name OPAQUE is always capitalized while the object type\nis\nnot (or don't say anything and trust the intelligence of the reader :-)\n\n-- You ask: should we blind both the identity and password?\n   Is the question whether IdU should be part of the input to the OPRF\n(together\n   with PwdU)? It is not necessary, I think, because kU is supposed to be\nunique\n   per user. Also, servers may use more than on IdU value to identify a\nuser or\n   use a value of IdU different than the one the user has (but we need some\n   agreement on the value of IdU for the sake of key derivation so maybe\nthis\n   would not be a problem if we wanted to use IdU as input to the OPRF).\n\n-- At registration the use chooses fresh keys (skU, pkU) =\nGenerateKeyPair().\n   Would it be possible that the user has a specific pair it wants to\nregister?\n   Maybe because it has a hardware token with these keys? But still uses the\n   envelope in case he left them at home...? WebAuth related?\n\n-- You say (regarding IdS): \"we should probably improve this a bit and\nprovide\n   guidance for where and how IdS is provisioned to clients\"\n   Probably such guidance is needed although there may be many use cases.\nOne\n   place where this id can be communicated is in the Response message from\nthe\n   server or in the envelope.\n\n-- Regarding the second stage you say: \"This stage is composed of a\nsequential\nOPRF and key exchange flow.\"\nDo not use the word sequential as we run them in parallel. In integration\nwith\nTLS we even start the KE part before the OPRF (exchanging DH values).\n\n-- \"client and server agree on the knowledge of the password and have\nmutually\nauthenticated one another\"\nThis is more like: Client proves user's knowledge of the password and agree\non a\nmutually authenticated shared secret key.\n\n-- In the online stage, should IdS be (at least an optional) input to the\nclient? It needs it to contact the server. Otoh, the name IdS used later in\nthe\nprotocol may be different than the one the client initially has for\ncontacting\nthe server, especially if IdS is communicated in the envelope.\n\n-- the context value is always derived as fresh randomness. However, it\nwould\nmake sense to set this value to the KE nonces (particularly in the case of\nTLS).\n\n-- Specification of the key-exchange protocol is out of scope for this\ndocument.\nThere is one point where the two components, OPRF and AKE, need to be bound\ntogether. This can be done by adding OPRF1 (what I call the value alpha) to\nthe\ndata authenticated by the KE. In the current specific, as I wrote it, all\nof the\nOPRF transcript (and even the envelope) is authenticated, not because this\nis\nneeded but because it is simpler to just add everything to the stream of\nauthenticated data. Anyway, the point is that this binding needs to be\naccommodated in gluing the OPRF and KE.\n\n-- Generic committed encryption. I am not convinced that the use of RKR here\njustifies a separate document. The main reason for having such document is\nbecause the trivial solution, namely, encrypt-then-CRmac (CRmac is any MAC\nthat\nis collision resistant), is slow for large pieces of data which is not the\ncase\nhere. I am afraid that such separate document will have much more complexity\nthat what's needed here, and we will end recommending using\nencrypt-then-hmac\nfor OPAQUE (it is the most robust mode for RKR encryption). I would have\nhoped\nto have a spec for it already but even defining it specifically for OPAQUE\nis\nnot a big deal. One issue is that given the popularity of GCM, people will\nwant\nto use it as the encryption part.  This is not a problem security-wise but\nwastes computation and bandwidth (not sure how serious this is). That's why\nI\ndefined standalone counter mode encryption (another self-contained spec I\ncould\nnot find).\n\n\n\nOn Sat, May 23, 2020 at 10:59 AM Christopher Wood <notifications@github.com>\nwrote:\n\n> This change shuffles around content and replaces the text-based protocol\n> descriptions with protocol flows and messages. It also includes a first cut\n> at wire format details for these messages. (We can always iterate later on!)\n>\n> cc @hugokraw <https://github.com/hugokraw>\n> ------------------------------\n> You can view, comment on, or merge this pull request online at:\n>\n>   https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17\n> Commit Summary\n>\n>    - Work in progress on the wire format details.\n>    - Merge branch 'master' of github.com:cfrg/draft-irtf-cfrg-opaque into\n>    caw/wire-formats\n>    - Finish online authentication phase.\n>\n> File Changes\n>\n>    - *M* draft-irtf-cfrg-opaque.md\n>    <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17/files#diff-49c06d6581f7de28ecde5fcfac409830>\n>    (929)\n>\n> Patch Links:\n>\n>    - https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17.patch\n>    - https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17.diff\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17>, or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXSS5EXWDTICPK34XZDRS7QD7ANCNFSM4NIPH3UQ>\n> .\n>\n",
          "createdAt": "2020-05-24T16:07:56Z",
          "updatedAt": "2020-05-24T16:07:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI0NjczODg3",
      "title": "Generate nonces randomly.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/24",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #23.",
      "createdAt": "2020-05-28T19:01:02Z",
      "updatedAt": "2020-05-29T00:44:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "21de69f0b70488207df108cd25023ed421be24df",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/random-nonces",
      "headRefOid": "7d7a9bdc07b6bb8cb68336c2e92903fd3391034c",
      "closedAt": "2020-05-29T00:44:49Z",
      "mergedAt": "2020-05-29T00:44:49Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f39bcc8e8a4aceefeff19d778ceb4e6dcb0de1ec"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1MDkyMjQ4",
      "title": "Add HMQV key derivation changes.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/28",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #18.",
      "createdAt": "2020-05-29T13:06:33Z",
      "updatedAt": "2020-05-29T15:08:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f39bcc8e8a4aceefeff19d778ceb4e6dcb0de1ec",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hmqv-changes",
      "headRefOid": "2576ebb427c8bd9d189a2b6687c44f2dae839bfe",
      "closedAt": "2020-05-29T15:08:36Z",
      "mergedAt": "2020-05-29T15:08:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3a62bfb1ac0a1cc6e0d8f2492da0256724805be1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDQyMzUy",
          "commit": {
            "abbreviatedOid": "2576ebb"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-29T15:08:08Z",
          "updatedAt": "2020-05-29T15:08:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI4MDc4Mjgz",
      "title": "Replace Encode/Decode with Serialize/Deserialize.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/32",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is to match the VOPRF document, which uses Serialize/Deserialize. (Encode was also used as a type of Hash in hash-to-curve, so this is probably better.)",
      "createdAt": "2020-06-04T20:44:51Z",
      "updatedAt": "2020-06-05T16:00:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "41068ef6e0a02eed821764cc80ab8fe7fa084e32",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/encode-to-serialize",
      "headRefOid": "49033dd3d7167467e3ad9f7738160f4801e450be",
      "closedAt": "2020-06-05T16:00:44Z",
      "mergedAt": "2020-06-05T16:00:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7b2ac5fad20d031fedd697e5fe5ff2a75b245902"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1Mzk2Mjgz",
          "commit": {
            "abbreviatedOid": "49033dd"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-05T15:20:40Z",
          "updatedAt": "2020-06-05T15:20:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI4MTM3NTIw",
      "title": "Fix and relocate KdKey derivation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/33",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This moves derivation of the KdKey to the main protocol flow (outside of the RKR-AEAD algorithm), uses HKDF-Extract for secret derivation, and renames KdKey to exporter_key. ",
      "createdAt": "2020-06-04T23:17:51Z",
      "updatedAt": "2020-06-05T18:04:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "41068ef6e0a02eed821764cc80ab8fe7fa084e32",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/kdkey",
      "headRefOid": "f2dcf38c76c026d6b78b1195b9c48fd730691800",
      "closedAt": "2020-06-05T18:04:34Z",
      "mergedAt": "2020-06-05T18:04:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d4e6be35083e0280e749c87f6140ef1a13072f13"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I want to beef up the explanation of how the exporter_key may be used but no need to keep this open now.\r\n\r\nYeah, more text would certainly be useful. I figured we could do that in another PR. :-)",
          "createdAt": "2020-06-05T18:04:25Z",
          "updatedAt": "2020-06-05T18:04:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTEwNjQ2",
          "commit": {
            "abbreviatedOid": "f2dcf38"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It looks fine. I want to beef up the explanation of how the exporter_key may be used but no need to keep this open now. ",
          "createdAt": "2020-06-05T18:00:51Z",
          "updatedAt": "2020-06-05T18:00:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM0MzgwMTYz",
      "title": "Addressing minor grammar and typo fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/34",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Mostly addressing some minor grammar fixes and typos that I found during my pass.\r\n\r\nI also renamed \"xcript2\", \"xcript3\" to \"transcript2\" and \"transcript3\", feel free to push back on that.\r\n\r\nI noticed also that in some places it is referred to as \"xcript2\" and others it is \"xscript2\", at the very least those should be made consistent.",
      "createdAt": "2020-06-15T08:39:51Z",
      "updatedAt": "2020-12-16T09:54:46Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "b5894704b46ed915abf4d1c98734651caf59bb58",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "typo_fixes",
      "headRefOid": "245688a2d5779e7dd6b22d274e9ab439de59a299",
      "closedAt": "2020-06-15T14:23:27Z",
      "mergedAt": "2020-06-15T14:23:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "df8af66cf5dd6cf86c7c07fa7c853a6e7a42df44"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNjgyODcw",
          "commit": {
            "abbreviatedOid": "245688a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-06-15T14:12:19Z",
          "updatedAt": "2020-06-15T14:12:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 35,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NTc1MDM3",
      "title": "Add 256-bit curve suites.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/35",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We address static DH oracle attacks in the security considerations. Nothing to be worried about! :-)",
      "createdAt": "2020-06-17T03:12:09Z",
      "updatedAt": "2020-06-17T13:10:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "df8af66cf5dd6cf86c7c07fa7c853a6e7a42df44",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/oprf-suites",
      "headRefOid": "b2b814034fcd2863c1307d2bccf70850b9194ec9",
      "closedAt": "2020-06-17T13:10:39Z",
      "mergedAt": "2020-06-17T13:10:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5b15b1938e36d068e600eed46442ec3cb3317e9a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMDY4ODQ3",
          "commit": {
            "abbreviatedOid": "b2b8140"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good.",
          "createdAt": "2020-06-17T05:30:00Z",
          "updatedAt": "2020-06-17T05:30:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1OTY0MTE5",
      "title": "Remove RKR-AEAD dependency.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This removes the RKR-AEAD dependency in favor of a simpler OTP-like construction for credential secrecy. It also replaces redundant Extract calls on RwdU with Expand calls (RwdU is already assumed to be the output of a RO). Finally, it removes the `context` parameter from all protocol messages, punting that functionality to applications.",
      "createdAt": "2020-06-17T16:29:13Z",
      "updatedAt": "2020-06-18T23:04:26Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "5b15b1938e36d068e600eed46442ec3cb3317e9a",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/otp",
      "headRefOid": "7fa14ae888c0edc05973148faee435b0a2fd3396",
      "closedAt": "2020-06-18T23:04:26Z",
      "mergedAt": "2020-06-18T23:04:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ed6bbd3cbffa33a78dd3c03369423d3280a11023"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Chris, I have several comments/corrections for PR #36.\nLet me know if there is a better way to communicate such things in github\nrather than as an email.\n\nHere is a list (items marked by *)\n\nLet me know if you have questions or need more clarity on these issues.\n\n\n* Question (pure curiosity): What was the functionality of the \"context\"\nvalue\nwhat was context\n\n* Line 642: Envelope is defined as an encryption of a Credentials\nstructure, but\n  encryption is only required for skU. Maybe \"an authenticated encoding\"\ninstead\n  of encryption, since everything in it requires authentication.\n\n(same appears in line 821)\n\n* params, the MHF parameters established out of band\n\nShouldn't we allow for params to be communicated by the server to client\n(this\nwould be another potential element of Envelope)\n\n* Calculation of keys using HKDF-Expand (lines 720..., also 891...)\n\nHere is how the calculation should look:\n\npseudorandom_pad = HKDF-Expand(Key=RwdU, info = nonce | \"Pad\", len(pt))\nauth_key         = HKDF-Expand(Key=RwdU, info = nonce | \"AuthKey\", Na)\nexporter_key     = HKDF-Expand(Key=RwdU, info = nonce | \"ExporterKey\", Ne)\n\nThe keywords Key= and info= are not needed. RFC 5869 defines HKDF-Expand\nwith\nthree parameters corresponding to key, info and length, so just writing\npseudorandom_pad = HKDF-Expand(RwdU, nonce | \"Pad\", len(pt))\nshould be enough\n(I write the name of the fields to clarify the semantics but this is not\nneeded\nfor specification).\n\nBtw, I prefer \"nonce\" or \"Nonce\" better than n.\n\nAlso: Is Ne (the length of exporter_key) defined?\nWe can use the same length for auth_key and exporter_key - they should be\nHashLen where this denotes the output length from the hash underlying HKDF\n(or\nHMAC)\n\n* Encryption and aad\n\nYou define (line 718)\n  pt = SerializeCredentials(C)\nand then (line 723)\n  ct = xor(pt, pseudorandom_pad)\nwhich means you are mandating the encryption of all fields in Credentials.\nI don't think we want to do that.\nSome people (like Kevin and I got this feedback from AWS too) want to keep\npkS\nunencrypted so we should accommodate that.\nI also find the text in line 733-736 confusing.\nShouldn't the SerializeCredentials get as input an indication of what\nCredentials fields are included and which are part of pt and which of aad?\n\nIn particular I don't like to leave this to the application:\n  \"Instantiations of OPAQUE MUST specify how aad is constructed and\nserialized.\"\nShouldn't the OPAQUE client be standardized independently of the\napplications?\n\n> Is it ok to leave it up to the application? Don't you want to build\ngeneric\nclients? Can't the SerializeCredentials function have as input the\nencrypted and\nauthenticated elements?\n\nBtw, you use the notation pk(skU) but this is denoted by the simple pkU\n\n* Important correction\n\nWhere it says (line 724):\n\nt = HMAC(auth_key, concat(ct, aad)),  where aad is application-specific\n\nit should be\n\nt = HMAC(auth_key, concat(n, ct, aad)),  where aad is application-specific\n\nthe nonce needs to be authenticated (it's my fault, I overlooked it in the\ntext\nI sent you).\n\n* line 896 Abort(): should one define an error message for it?\n\n\n\nOn Wed, Jun 17, 2020 at 12:34 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> @chris-wood <https://github.com/chris-wood> requested your review on: #36\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36> Remove RKR-AEAD\n> dependency..\n>\n> \u2014\n> You are receiving this because your review was requested.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36#event-3454432475>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXX5T5AHOTNA2WBILLDRXDWAVANCNFSM4OAYKGZQ>\n> .\n>\n",
          "createdAt": "2020-06-18T02:17:40Z",
          "updatedAt": "2020-06-18T02:17:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> * Question (pure curiosity): What was the functionality of the \"context\" value what was context \r\n\r\nIt was meant to link requests/responses together. But that's something that can be handled by the instantiation (OPAQUE-EA in this case).\r\n\r\n> * Line 642: Envelope is defined as an encryption of a Credentials structure, but encryption is only required for skU. Maybe \"an authenticated encoding\" instead of encryption, since everything in it requires authentication. (same appears in line 821) \r\n\r\nThat works for me -- I'll use that text.\r\n\r\n> * params, the MHF parameters established out of band Shouldn't we allow for params to be communicated by the server to client (this would be another potential element of Envelope) \r\n\r\nI don't think so. Clients can choose to harden the password using whatever parameters they wish, right? Why does the server need to have any input here?\r\n\r\n> * Calculation of keys using HKDF-Expand (lines 720..., also 891...) Here is how the calculation should look: pseudorandom_pad = HKDF-Expand(Key=RwdU, info = nonce | \"Pad\", len(pt)) auth_key = HKDF-Expand(Key=RwdU, info = nonce | \"AuthKey\", Na) exporter_key = HKDF-Expand(Key=RwdU, info = nonce | \"ExporterKey\", Ne) The keywords Key= and info= are not needed. RFC 5869 defines HKDF-Expand with three parameters corresponding to key, info and length, so just writing pseudorandom_pad = HKDF-Expand(RwdU, nonce | \"Pad\", len(pt)) should be enough (I write the name of the fields to clarify the semantics but this is not needed for specification). \r\n\r\nTo be clear, you're just suggesting removing the argument labels (\"key=\"), right? I don't see any difference between concat(nonce, \"Pad\") and concat(\"Pad\", nonce). \r\n\r\n> Btw, I prefer \"nonce\" or \"Nonce\" better than n. Also: Is Ne (the length of exporter_key) defined? We can use the same length for auth_key and exporter_key - they should be HashLen where this denotes the output length from the hash underlying HKDF (or HMAC) \r\n\r\nYep, Ne is the length of the exporter key. It's a parameter to the functions where it's used. I folded Na and Ne together. I'll specify a value for this in a separate PR.\r\n\r\n> * Encryption and aad You define (line 718) pt = SerializeCredentials(C) and then (line 723) ct = xor(pt, pseudorandom_pad) which means you are mandating the encryption of all fields in Credentials. I don't think we want to do that. Some people (like Kevin and I got this feedback from AWS too) want to keep pkS unencrypted so we should accommodate that. I also find the text in line 733-736 confusing. Shouldn't the SerializeCredentials get as input an indication of what Credentials fields are included and which are part of pt and which of aad? In particular I don't like to leave this to the application: \"Instantiations of OPAQUE MUST specify how aad is constructed and serialized.\" Shouldn't the OPAQUE client be standardized independently of the applications?\r\n\r\nI don't know of a good way to specify this in the pseudocode without a mess of branches. I think the default case should be to encrypt pkS, and we can specify variants (moving pkS out of Credentials and into aad, for example) in the text. But we can also flip that around and make the default case be to only authenticate pkS, with text suggesting it may optionally be encrypted. Would that work?\r\n\r\n> Is it ok to leave it up to the application? Don't you want to build generic clients? Can't the SerializeCredentials function have as input the encrypted and authenticated elements? \r\n\r\nI'm not sure what you mean here. By leaving it up to applications, we are allowing generic clients to use this as needed.\r\n\r\n> Btw, you use the notation pk(skU) but this is denoted by the simple pkU \r\n\r\nThat works. :-)\r\n\r\n> * Important correction Where it says (line 724): t = HMAC(auth_key, concat(ct, aad)), where aad is application-specific it should be t = HMAC(auth_key, concat(n, ct, aad)), where aad is application-specific the nonce needs to be authenticated (it's my fault, I overlooked it in the text I sent you). \r\n\r\nWhoops -- yes, will fix!\r\n\r\n>* line 896 Abort(): should one define an error message for it?\r\n\r\nI replaced this with \"raise DecryptionError\", to make it a bit more clear.",
          "createdAt": "2020-06-18T02:43:03Z",
          "updatedAt": "2020-06-18T02:43:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw -- I updated this based on your feedback above. Everything should be accounted for, but please let me know if not!",
          "createdAt": "2020-06-18T02:45:31Z",
          "updatedAt": "2020-06-18T02:45:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw, I pushed one more update that separates application AAD and the authentication-only data in credentials. Hopefully this is more clear!",
          "createdAt": "2020-06-18T03:08:02Z",
          "updatedAt": "2020-06-18T03:08:02Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "On Wed, Jun 17, 2020 at 10:43 PM Christopher Wood <notifications@github.com>\nwrote:\n\n>\n>    - Question (pure curiosity): What was the functionality of the\n>    \"context\" value what was context\n>\n> It was meant to link requests/responses together. But that's something\n> that can be handled by the instantiation (OPAQUE-EA in this case).\n>\n>\n>    - Line 642: Envelope is defined as an encryption of a Credentials\n>    structure, but encryption is only required for skU. Maybe \"an authenticated\n>    encoding\" instead of encryption, since everything in it requires\n>    authentication. (same appears in line 821)\n>\n> That works for me -- I'll use that text.\n>\n>\n>    - params, the MHF parameters established out of band Shouldn't we\n>    allow for params to be communicated by the server to client (this would be\n>    another potential element of Envelope)\n>\n> I don't think so. Clients can choose to harden the password using whatever\n> parameters they wish, right? Why does the server need to have any input\n> here?\n>\nThe question is how the client knows at login time what parameters it has\nto use. The client machine may be running OPAQUE instances with different\nservers and users that have different parameters. In such a case, the\nserver needs to store these parameters (that were set a password\nregistration phase)  and send them to the client.\n\n\n>    - Calculation of keys using HKDF-Expand (lines 720..., also 891...)\n>    Here is how the calculation should look: pseudorandom_pad =\n>    HKDF-Expand(Key=RwdU, info = nonce | \"Pad\", len(pt)) auth_key =\n>    HKDF-Expand(Key=RwdU, info = nonce | \"AuthKey\", Na) exporter_key =\n>    HKDF-Expand(Key=RwdU, info = nonce | \"ExporterKey\", Ne) The keywords Key=\n>    and info= are not needed. RFC 5869 defines HKDF-Expand with three\n>    parameters corresponding to key, info and length, so just writing\n>    pseudorandom_pad = HKDF-Expand(RwdU, nonce | \"Pad\", len(pt)) should be\n>    enough (I write the name of the fields to clarify the semantics but this is\n>    not needed for specification).\n>\n> To be clear, you're just suggesting removing the argument labels (\"key=\"),\n> right? I don't see any difference between concat(nonce, \"Pad\") and\n> concat(\"Pad\", nonce).\n>\nYes, that is what I was suggesting but note that the change from what you\nhad before is much more significant than that. You had\nHKDF-Expand(salt=n, IKM=RwdU, \"Pad\", len(pt))\nwhich uses the nonce as salt, but only HKDF-Extract uses salt, not Expand.\n\nBtw, I prefer \"nonce\" or \"Nonce\" better than n. Also: Is Ne (the length of\n> exporter_key) defined? We can use the same length for auth_key and\n> exporter_key - they should be HashLen where this denotes the output length\n> from the hash underlying HKDF (or HMAC)\n>\n> Yep, Ne is the length of the exporter key. It's a parameter to the\n> functions where it's used. I folded Na and Ne together. I'll specify a\n> value for this in a separate PR.\n>\n>\n>    - Encryption and aad You define (line 718) pt =\n>    SerializeCredentials(C) and then (line 723) ct = xor(pt, pseudorandom_pad)\n>    which means you are mandating the encryption of all fields in Credentials.\n>    I don't think we want to do that. Some people (like Kevin and I got this\n>    feedback from AWS too) want to keep pkS unencrypted so we should\n>    accommodate that. I also find the text in line 733-736 confusing. Shouldn't\n>    the SerializeCredentials get as input an indication of what Credentials\n>    fields are included and which are part of pt and which of aad? In\n>    particular I don't like to leave this to the application: \"Instantiations\n>    of OPAQUE MUST specify how aad is constructed and serialized.\" Shouldn't\n>    the OPAQUE client be standardized independently of the applications?\n>\n> I don't know of a good way to specify this in the pseudocode without a\n> mess of branches. I think the default case should be to encrypt pkS, and we\n> can specify variants (moving pkS out of Credentials and into aad, for\n> example) in the text. But we can also flip that around and make the default\n> case be to only authenticate pkS, with text suggesting it may optionally be\n> encrypted. Would that work?\n>\nWhy can't you have two components in Credentials: pt and aad, and the\napplication chooses which fields to map to each one? I understand that what\nyou propose is simpler but it also requires customizing the client to\ndifferent applications. In the case where the client is \"written\" for a\nspecific application, that's fine, but if you have a situation where the\nsame client interacts with different applications/servers then things\nbecome problematic.\n\nIs it ok to leave it up to the application? Don't you want to build generic\n> clients? Can't the SerializeCredentials function have as input the\n> encrypted and authenticated elements?\n>\n> I'm not sure what you mean here. By leaving it up to applications, we are\n> allowing generic clients to use this as needed.\n>\nI am thinking of a web browser running OPAQUE (as a client) with different\nservers that may have different policies regarding what is\nincluded/encrypted/authenticated. So you want a standardized way for the\nserver to  communicate the structure of the envelope to the browser.\n\n\n> Btw, you use the notation pk(skU) but this is denoted by the simple pkU\n>\n> That works. :-)\n>\n>\n>    - Important correction Where it says (line 724): t = HMAC(auth_key,\n>    concat(ct, aad)), where aad is application-specific it should be t =\n>    HMAC(auth_key, concat(n, ct, aad)), where aad is application-specific the\n>    nonce needs to be authenticated (it's my fault, I overlooked it in the text\n>    I sent you).\n>\n> Whoops -- yes, will fix!\n>\n>\n>    - line 896 Abort(): should one define an error message for it?\n>\n> I replaced this with \"raise DecryptionError\", to make it a bit more clear.\n>\n> \u2014\n> You are receiving this because your review was requested.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36#issuecomment-645735586>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXXW5OCWTJT6XD646JTRXF5MHANCNFSM4OAYKGZQ>\n> .\n>\n",
          "createdAt": "2020-06-18T04:29:52Z",
          "updatedAt": "2020-06-18T04:29:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The question is how the client knows at login time what parameters it has to use. The client machine may be running OPAQUE instances with different servers and users that have different parameters. In such a case, the server needs to store these parameters (that were set a password registration phase)  and send them to the client.\r\n\r\nAh, okay, good point. I was assuming the application was \"fixed,\" e.g., a mobile app in which the parameters are baked into the code. But that might not always be the case. I'll just revert this for now.\r\n\r\n> Why can't you have two components in Credentials: pt and aad, and the application chooses which fields to map to each one? I understand that what you propose is simpler but it also requires customizing the client to different applications. In the case where the client is \"written\" for a specific application, that's fine, but if you have a situation where the same client interacts with different applications/servers then things become problematic.\r\n\r\nSent an email to discuss offline!",
          "createdAt": "2020-06-18T05:05:15Z",
          "updatedAt": "2020-06-18T05:05:15Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the difference in our approaches/expectations is that you think of\nOPAQUE for use inside a standalone application that has full control of the\nclient and I think more about a \"universal\" mechanism, e.g., a standardized\nbrowser-based client.\n\nOn Thu, Jun 18, 2020 at 1:05 AM Christopher Wood <notifications@github.com>\nwrote:\n\n> The question is how the client knows at login time what parameters it has\n> to use. The client machine may be running OPAQUE instances with different\n> servers and users that have different parameters. In such a case, the\n> server needs to store these parameters (that were set a password\n> registration phase) and send them to the client.\n>\n> Ah, okay, good point. I was assuming the application was \"fixed,\" e.g., a\n> mobile app in which the parameters are baked into the code. But that might\n> not always be the case. I'll just revert this for now.\n>\n> Why can't you have two components in Credentials: pt and aad, and the\n> application chooses which fields to map to each one? I understand that what\n> you propose is simpler but it also requires customizing the client to\n> different applications. In the case where the client is \"written\" for a\n> specific application, that's fine, but if you have a situation where the\n> same client interacts with different applications/servers then things\n> become problematic.\n>\n> Sent an email to discuss offline!\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36#issuecomment-645774735>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXVWM7BCPBSA5PNEDKTRXGOBPANCNFSM4OAYKGZQ>\n> .\n>\n",
          "createdAt": "2020-06-18T20:26:37Z",
          "updatedAt": "2020-06-18T20:26:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjg4MzY5",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:26:41Z",
          "updatedAt": "2020-06-18T22:26:42Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "I prefer OPAQUE credentials than application credentials",
              "createdAt": "2020-06-18T22:26:41Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjg5Mjgw",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:28:57Z",
          "updatedAt": "2020-06-18T22:28:58Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "I would not call all of them essential, just skU and pkS are.\r\n\r\nDo we want to restrict to just these five or leave further extensibility in case it is needed (e.g., we were discussing the hardening parameters as a possible addition to the envelope).\r\n",
              "createdAt": "2020-06-18T22:28:58Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjg5ODYy",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:30:21Z",
          "updatedAt": "2020-06-18T22:30:21Z",
          "comments": [
            {
              "originalPosition": 218,
              "body": "Applications credentials that require authentication but not secrecy",
              "createdAt": "2020-06-18T22:30:21Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjkwNDQ0",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:31:50Z",
          "updatedAt": "2020-06-18T22:31:51Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "maybe auth_tag instead of just tag? (not too important)",
              "createdAt": "2020-06-18T22:31:50Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjkyMDIz",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:36:05Z",
          "updatedAt": "2020-06-18T22:36:05Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "I noted that skU and pkS are mandatory. We might want to leave room for other things. The hardening parameters might be one of them, if they aren't transmitted at the application layer.",
              "createdAt": "2020-06-18T22:36:05Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjkzNzky",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:40:39Z",
          "updatedAt": "2020-06-18T22:40:39Z",
          "comments": [
            {
              "originalPosition": 399,
              "body": "How is server policy (what is encrypted and what is not in the envelope) communicated to the client? DO we need a special message (echoing the credentials structure) for that?",
              "createdAt": "2020-06-18T22:40:39Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk0NDc0",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:42:21Z",
          "updatedAt": "2020-06-18T22:42:21Z",
          "comments": [
            {
              "originalPosition": 382,
              "body": "what is the use of aad (additional to auth_data)?",
              "createdAt": "2020-06-18T22:42:21Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk0NzQ4",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:43:07Z",
          "updatedAt": "2020-06-18T22:43:07Z",
          "comments": [
            {
              "originalPosition": 382,
              "body": "Any AAD specific to the application, really. It's an opaque slot.",
              "createdAt": "2020-06-18T22:43:07Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk1MDE0",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:43:50Z",
          "updatedAt": "2020-06-18T22:43:51Z",
          "comments": [
            {
              "originalPosition": 407,
              "body": "Do we need aad? If so, where is it transmitted? It is not part of the envelope.",
              "createdAt": "2020-06-18T22:43:50Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk1NTYx",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:45:12Z",
          "updatedAt": "2020-06-18T22:45:12Z",
          "comments": [
            {
              "originalPosition": 399,
              "body": "I figured it'd be best to omit that from this, since it's an application-specific detail. But we could probably have the server be crystal clear about this inline. ",
              "createdAt": "2020-06-18T22:45:12Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk1NjE0",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:45:20Z",
          "updatedAt": "2020-06-18T22:45:20Z",
          "comments": [
            {
              "originalPosition": 407,
              "body": "Yes, I think so.",
              "createdAt": "2020-06-18T22:45:20Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk2MDQ5",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:46:27Z",
          "updatedAt": "2020-06-18T22:46:27Z",
          "comments": [
            {
              "originalPosition": 423,
              "body": "We need to specify that *all* values in EnvU require authentication, only secrecy is optional (except for skU for which it is mandatory)",
              "createdAt": "2020-06-18T22:46:27Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk2MTcy",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:46:47Z",
          "updatedAt": "2020-06-18T22:46:48Z",
          "comments": [
            {
              "originalPosition": 423,
              "body": "I think that's already clear from context, no?",
              "createdAt": "2020-06-18T22:46:48Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk3MDI3",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:49:10Z",
          "updatedAt": "2020-06-18T22:49:10Z",
          "comments": [
            {
              "originalPosition": 535,
              "body": "pkS is a mandatory part of EnvU",
              "createdAt": "2020-06-18T22:49:10Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk4ODI0",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:54:01Z",
          "updatedAt": "2020-06-18T22:54:01Z",
          "comments": [
            {
              "originalPosition": 564,
              "body": "why tag?",
              "createdAt": "2020-06-18T22:54:01Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk5NTcz",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:56:06Z",
          "updatedAt": "2020-06-18T22:56:06Z",
          "comments": [
            {
              "originalPosition": 402,
              "body": "Make reference to RFC 5869 about the roles of the three inputs to HKDF-Expand, namely, key, info, and output length.",
              "createdAt": "2020-06-18T22:56:06Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAwNzMx",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:13Z",
          "updatedAt": "2020-06-18T22:59:14Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "(This list is meant to be extended, basically.)",
              "createdAt": "2020-06-18T22:59:14Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAwODYz",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:34Z",
          "updatedAt": "2020-06-18T22:59:35Z",
          "comments": [
            {
              "originalPosition": 535,
              "body": "I removed this left-over text.",
              "createdAt": "2020-06-18T22:59:34Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAwODk3",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:41Z",
          "updatedAt": "2020-06-18T22:59:41Z",
          "comments": [
            {
              "originalPosition": 564,
              "body": "Bug -- fixed!",
              "createdAt": "2020-06-18T22:59:41Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAwOTIx",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:45Z",
          "updatedAt": "2020-06-18T22:59:46Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "I guess that aad should be replaced here with cleartext_credentials? ",
              "createdAt": "2020-06-18T22:59:46Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAxMDAz",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:57Z",
          "updatedAt": "2020-06-18T22:59:58Z",
          "comments": [
            {
              "originalPosition": 402,
              "body": "I added a reference at the end of this algorithm.",
              "createdAt": "2020-06-18T22:59:57Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAxMzA4",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T23:00:44Z",
          "updatedAt": "2020-06-18T23:00:44Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "Yep, good catch!",
              "createdAt": "2020-06-18T23:00:44Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAxMzkw",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I approve this but see the comments I have interleaved in the code",
          "createdAt": "2020-06-18T23:00:57Z",
          "updatedAt": "2020-06-18T23:00:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2ODEyMzE4",
      "title": "Remove TLS 1.3 integration details.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/38",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #2.\r\n\r\nThis removes TLS 1.3 integration details, but keeps the SIGMA-I content. (TLS 1.3 details will go in the TLS document.)",
      "createdAt": "2020-06-18T23:35:42Z",
      "updatedAt": "2020-06-19T15:14:46Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "683cb6842f4a9e862cc5982247afdc4ce2526282",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/remove-tls",
      "headRefOid": "2196764fc36b09dbb5719a18760c6d1b8d1ab604",
      "closedAt": "2020-06-19T15:14:46Z",
      "mergedAt": "2020-06-19T15:14:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "13cb903eee61256b31c08b1dadbbabe47d3fcee6"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I love that line :-D",
          "createdAt": "2020-06-19T15:11:58Z",
          "updatedAt": "2020-06-19T15:11:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzk5OTUx",
          "commit": {
            "abbreviatedOid": "cfb1c92"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good. I would still have some text pointing to the need to integrate with TLS to achieve user account privacy and to implement the record layer where information is protected by keys generated/authenticated by OPAQUE. \r\n\r\nSomewhat related, I would like to keep this remark (possible re-phrased and shortened): \r\n   Note on user authentication vs. authenticated key exchange. OPAQUE\r\n   provides PAKE (password-based authenticated key exchange)\r\n   functionality in the client-server setting. While in the case of user\r\n   identification, focus is often on the authentication part, we stress\r\n   that the key exchange element is not less crucial. Indeed, in most\r\n   cases user authentication is performed to enforce some policy, and\r\n   the key exchange part is essential for binding this enforcement to\r\n   the authentication step. Skipping the key exchange part is analogous\r\n   to carefully checking a visitor's credential at the door and then \r\n   leaving the door open for others to enter freely.",
          "createdAt": "2020-06-19T04:49:35Z",
          "updatedAt": "2020-06-19T04:49:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2ODI0NDgy",
      "title": "Move configuration information to separate section.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/39",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This shuffles content around, mostly.",
      "createdAt": "2020-06-19T00:24:24Z",
      "updatedAt": "2020-06-19T15:06:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "12c2440575fd2bb47a3aaaeffc7152806b44d94a",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/configurations",
      "headRefOid": "56231a77e51785ee2ba6ec9d55bcf2aa8549facf",
      "closedAt": "2020-06-19T15:06:44Z",
      "mergedAt": "2020-06-19T15:06:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "683cb6842f4a9e862cc5982247afdc4ce2526282"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzk3NzA0",
          "commit": {
            "abbreviatedOid": "56231a7"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-19T04:41:06Z",
          "updatedAt": "2020-06-19T04:41:06Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "It is TBD how the server does that",
              "createdAt": "2020-06-19T04:41:06Z",
              "updatedAt": "2020-06-19T04:41:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzk3Nzc2",
          "commit": {
            "abbreviatedOid": "56231a7"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-19T04:41:24Z",
          "updatedAt": "2020-06-19T04:41:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTUwNTIx",
          "commit": {
            "abbreviatedOid": "56231a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-19T15:06:38Z",
          "updatedAt": "2020-06-19T15:06:39Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Yeah, we'll need to work out a way to do this before revving the draft.",
              "createdAt": "2020-06-19T15:06:38Z",
              "updatedAt": "2020-06-19T15:06:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3MTM3MDYw",
      "title": "Exporter -> export, adding HKDF-Extract around Harden call",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/40",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should wrap the Harden() call with an HKDF-Extract call, since there is no guarantee that Harden will output pseudorandom bits\r\n\r\nAlso changed \"exporter key\" to read simply as \"export key\"",
      "createdAt": "2020-07-09T23:08:17Z",
      "updatedAt": "2020-12-16T09:54:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "120464d640d093ff99da8d8350766aafb5f28974",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "add_hkdf_extract",
      "headRefOid": "f136373e87fad07782041b9129ff36e73e3b98fb",
      "closedAt": "2020-07-11T00:30:40Z",
      "mergedAt": "2020-07-11T00:30:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "aae69344bcc40290a825b9503540f607e48bcac7"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ",
          "createdAt": "2020-07-10T22:35:47Z",
          "updatedAt": "2020-07-10T22:35:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzU5ODg1",
          "commit": {
            "abbreviatedOid": "f136373"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-07-11T00:30:34Z",
          "updatedAt": "2020-07-11T00:30:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ5NjkyNjU1",
      "title": "Recommend a particular encoding policy for skU, pkS, and IdS.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/41",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @kevinlewi ",
      "createdAt": "2020-07-15T19:41:04Z",
      "updatedAt": "2020-07-21T16:42:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "aae69344bcc40290a825b9503540f607e48bcac7",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/recommend-encoding",
      "headRefOid": "d31dd83f56078d8f3c00f19d953668e96cb6cfbf",
      "closedAt": "2020-07-21T16:42:39Z",
      "mergedAt": "2020-07-21T16:42:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "21f45acd09457f120470a946de1f9a9851b74de5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDYyMDY3",
          "commit": {
            "abbreviatedOid": "2de0620"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Regarding: \"to not store redundant encryptions of these (shared) values for each user.\" Reusing pkS with different users is not a must, and in principle even idS could be different for different users. So I would say something like \"to not store redundant encryptions of these values for each user in case the server uses the same values for multiple/all users.\" (Or something like that)\r\n\r\nThe word  '(shared)' with the meaning of \"common to multiple/all users\" may be unclear. Use something else (I couldconfusing as it could be shared with t",
          "createdAt": "2020-07-18T14:55:31Z",
          "updatedAt": "2020-07-18T14:55:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY3MDc1NTMw",
      "title": "Fixing length requirement typos for RegistrationResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/44",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- secret_types must contain at least skU\r\n- cleartext_types may be empty\r\n\r\nTherefore, lowering the length requirements of these vectors in RegistrationResponse to be 1 and 0, respectively.\r\n\r\nAlso updating my email and adding a close bracket",
      "createdAt": "2020-08-13T00:27:36Z",
      "updatedAt": "2020-12-16T09:54:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e03a8a3e945193567e99424db5bda83f33219fe9",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "typos_1",
      "headRefOid": "9f6b074d83ba64607fcd735f23f1b76832014057",
      "closedAt": "2020-08-20T19:52:46Z",
      "mergedAt": "2020-08-20T19:52:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f32a22595db939752bd94c51bb2a4cc1c53e24e6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxOTM4Nzg1",
          "commit": {
            "abbreviatedOid": "9f6b074"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-20T19:52:42Z",
          "updatedAt": "2020-08-20T19:52:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxNjI4NDQx",
      "title": "Align KE instantiations with the core protocol messages.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/45",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This aligns the KE instantiations with the core protocol messages, using them where appropriate instead of OPRF1/OPRF2/EnvU etc directly. ",
      "createdAt": "2020-08-21T13:18:40Z",
      "updatedAt": "2020-08-24T17:31:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f32a22595db939752bd94c51bb2a4cc1c53e24e6",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/align-kes",
      "headRefOid": "c3052cc22e44bd9cea52b02f4b947bbcbd7f7d38",
      "closedAt": "2020-08-24T17:31:51Z",
      "mergedAt": "2020-08-24T17:31:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d6fcfaa0ce739c702683cc555b7aa4d1d9cb251a"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I updated the change based on your comments. Thanks for the feedback! In response to your overall comment:\r\n\r\n> I left multiple comments, most minor. Two important issues to finalize is the derivation of keys for the KE protocols, specifically should we use a single call to HKDF or should we have separate calls for each key (in any case one needs to define the lengths of the individual keys). The other is to finalize some details in the computation of the HMQV key. I owe that to you.\r\n\r\nLet's update the key schedule in a separate PR. I'll await your input for the HMQV key derivation.",
          "createdAt": "2020-08-23T14:28:23Z",
          "updatedAt": "2020-08-23T14:28:45Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok. Just add to the last sentence:\n\nand KE3 provides explicit client authentication and full forward security\n(without it forward secrecy is only achieved against eavesdroppers)\n\nOn Sun, Aug 23, 2020 at 4:59 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> *@chris-wood* commented on this pull request.\n> ------------------------------\n>\n> In draft-irtf-cfrg-opaque.md\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/45#discussion_r475266680>\n> :\n>\n> > @@ -1015,28 +1022,27 @@ login.\n>\n>  # OPAQUE Instantiations {#instantiations}\n>\n> -We present several instantiations of OPAQUE using DH-OPRF\n> -and different KE protocols. For the sake of concreteness we focus on\n> -KE protocols consisting of three messages, denoted KE1, KE2, KE3, and\n> -such that KE1 and KE2 include DH values sent by user and server,\n> -respectively, and KE3 provides explicit user authentication.\n> +This section describes several instantiations of OPAQUE using different KE protocols.\n> +For the sake of concreteness it only includes KE protocols consisting of three messages,\n> +denoted KE1, KE2, KE3, where KE1 and KE2 include DH values sent by client and\n> +server, respectively, and KE3 provides explicit client authentication.\n>\n> I chose to keep this text (since it's not new, only copied). We can fix it\n> in a separate issue if needed.\n>\n> \u2014\n> You are receiving this because your review was requested.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/45#discussion_r475266680>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXSE3V6WRN7YOFAKQUTSCF7K7ANCNFSM4QHI6AMA>\n> .\n>\n",
          "createdAt": "2020-08-23T21:31:12Z",
          "updatedAt": "2020-08-23T21:31:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTc2MjE3",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T03:28:07Z",
          "updatedAt": "2020-08-23T03:28:08Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I do not like the \"at the end, the client proves the user's knowledge of the password\" as it sounds as if that is a step in the protocol. It is true that for the KE protocol to be successfully authenticated, the client must have possession of the user's password. Maybe you want to rephrase somehow.\r\n",
              "createdAt": "2020-08-23T03:28:07Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTc2ODIw",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T03:46:23Z",
          "updatedAt": "2020-08-23T03:46:24Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "This is existing text, but I\u2019ll see if we can rework it.",
              "createdAt": "2020-08-23T03:46:23Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTc2Mzg0",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I left multiple comments, most minor. Two important issues to finalize is the derivation of keys for the KE protocols, specifically should we use a single call to HKDF or should we have separate calls for each key (in any case one needs to define the lengths of the individual keys). The other is to finalize some details in the computation of the HMQV key. I owe that to you.",
          "createdAt": "2020-08-23T03:33:12Z",
          "updatedAt": "2020-08-23T05:46:38Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Just to make sure, this error should lead to aborting the session",
              "createdAt": "2020-08-23T03:33:12Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 85,
              "body": "All the protocols we describe provide explicit mutual authentication, so not sure I would single out the explicit authentication of the user, except if you feel the need to say what KE3 is for. Btw, in these protocols, the third message has the essential role of providing \"full forward security\" to the protocol. Without it, the protocol would only have weak forward secrecy which is not enough in general for OPAQUE security.",
              "createdAt": "2020-08-23T03:39:52Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 107,
              "body": "Can we say \"authenticate credential_request and credential_response, resepctively, ...\"?\r\nIt is longer but clearer (to me at least)",
              "createdAt": "2020-08-23T03:44:41Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 114,
              "body": "DH keys are for the HMQV and 3DH cases, not for SIGMA",
              "createdAt": "2020-08-23T03:57:44Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 193,
              "body": "Remove this last remark, it is not entirely correct.",
              "createdAt": "2020-08-23T04:08:01Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 164,
              "body": "Add here (or elsewhere) that  these ephemeral DH values need to be  verified to belong to the correct group (via membership tests or cofactor exponentiation, depending on curve details). The same holds for public keys during the registration phase.",
              "createdAt": "2020-08-23T04:23:28Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 114,
              "body": "Important: These public keys, exchanged during the registration phase  should be  verified to belong to the correct group (via membership tests or cofactor exponentiation, depending on curve details). ",
              "createdAt": "2020-08-23T04:24:50Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 209,
              "body": "Should we use the derivation style from TLS 1.3 and the rest of this document where each key has its own Expand call (and its own info/label value)? Either way, one needs to define the length of each of these keys (which depend on the MAC and encryption functions in use and whatever length one wants SK to be)",
              "createdAt": "2020-08-23T04:32:28Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 224,
              "body": "The definition of HMQV needs some care: the values u and s should be mapped to elements mod q where q is the order of the group and one should not use the hash function directly but some RO-like construction, maybe HKDF itself. I need to think about this. Also, the computation of Khmqv by the server (and similarly for the client) should first define the intermediate value  v = (eskS + u\\*skS) mod q and then compute Khmqv = (epkU \\* pkU^u)^v. I need to think about this some more. In particular, I need to check how you deal with some of similar issues, particularly RO hashing, in your definition of OPRF.",
              "createdAt": "2020-08-23T05:28:32Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 246,
              "body": "move nonceU before info1* for uniformity with the other specifications",
              "createdAt": "2020-08-23T05:34:35Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 258,
              "body": "IdU and IdS are defined in the explanation of these fields (appearing first for HMQV/3DH). In particular it is said there that IdU is the  identity used to create credential_request. I don't think it needs to be said here again (and if there is a reason for it, why only define IdU here and not also IdS?)",
              "createdAt": "2020-08-23T05:41:32Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDEzNTEw",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T13:55:28Z",
          "updatedAt": "2020-08-23T13:55:28Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "I'd be fine with that change. Specifying a key schedule similar to TLS 1.3 seems reasonable. Let me try and put that together.",
              "createdAt": "2020-08-23T13:55:28Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDEzNTgy",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T13:56:06Z",
          "updatedAt": "2020-08-23T13:56:06Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "I forgot to revert this -- thanks for flagging it.",
              "createdAt": "2020-08-23T13:56:06Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDEzNzY0",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T13:58:28Z",
          "updatedAt": "2020-08-23T13:58:28Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "I felt it was worth highlighting since otherwise it appears out fo context. I'll just remove it. ",
              "createdAt": "2020-08-23T13:58:28Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDEzOTA5",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T14:00:08Z",
          "updatedAt": "2020-08-23T14:00:09Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Yep!",
              "createdAt": "2020-08-23T14:00:09Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDE1Njk2",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T14:23:16Z",
          "updatedAt": "2020-08-23T14:23:16Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "(I'll do that in a followup change, to keep this diff smaller)",
              "createdAt": "2020-08-23T14:23:16Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDE1OTcz",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T14:26:25Z",
          "updatedAt": "2020-08-23T14:26:26Z",
          "comments": [
            {
              "originalPosition": 224,
              "body": "The OPRF document uses hash_to_curve where appropriate: https://tools.ietf.org/html/draft-irtf-cfrg-voprf-04#section-2.1",
              "createdAt": "2020-08-23T14:26:25Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDE2MTMz",
          "commit": {
            "abbreviatedOid": "9ddc0a0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T14:27:51Z",
          "updatedAt": "2020-08-23T14:27:51Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Yep, it does. If this isn't clear, I can add a note as such.",
              "createdAt": "2020-08-23T14:27:51Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDQ1MzE0",
          "commit": {
            "abbreviatedOid": "9ddc0a0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T20:59:15Z",
          "updatedAt": "2020-08-23T20:59:15Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I chose to keep this text (since it's not new, only copied). We can fix it in a separate issue if needed.",
              "createdAt": "2020-08-23T20:59:15Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcyNjczOTgx",
      "title": "Update the HMQV key derivation details. Clean up some presentation bugs.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/46",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-24T17:53:03Z",
      "updatedAt": "2020-08-25T03:55:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "d6fcfaa0ce739c702683cc555b7aa4d1d9cb251a",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hmqv-update",
      "headRefOid": "b3781464f814953b38080ac849589203e09e8ef5",
      "closedAt": "2020-08-24T22:41:28Z",
      "mergedAt": "2020-08-24T22:41:28Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "63a8acabd6e6420146cb38a0cd8f238688839107"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODIxMzAy",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I approve pending the attached review comments.",
          "createdAt": "2020-08-24T20:11:17Z",
          "updatedAt": "2020-08-24T21:27:24Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "#derive-3dh should be #derive-hmqv  here",
              "createdAt": "2020-08-24T20:11:17Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 51,
              "body": "let's change mod p to mod (len(p)-1)",
              "createdAt": "2020-08-24T20:14:08Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 44,
              "body": "Both client and server need to compute u and s, so it does not work to put the definition of u under the client computation and s under the server computation. They should go together at the beginning, at the end, or both as part of the user computation, and then saying that the server computes them same as the client.",
              "createdAt": "2020-08-24T20:17:18Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 74,
              "body": "change to:\r\nlen(\"server\") || \"server\"",
              "createdAt": "2020-08-24T21:17:02Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 75,
              "body": "change mod p to mod (len(p)-1)",
              "createdAt": "2020-08-24T21:17:57Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 81,
              "body": "remove last line",
              "createdAt": "2020-08-24T21:19:38Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODcwMDM4",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T21:29:13Z",
          "updatedAt": "2020-08-24T21:29:13Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Oops, wrong headers!",
              "createdAt": "2020-08-24T21:29:13Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODcwODMz",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T21:30:40Z",
          "updatedAt": "2020-08-24T21:30:40Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "hah, I thought I copied the right text!",
              "createdAt": "2020-08-24T21:30:40Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODcxMzA4",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T21:31:33Z",
          "updatedAt": "2020-08-24T21:31:34Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "Which line?",
              "createdAt": "2020-08-24T21:31:33Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczOTQyMzQz",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T22:40:57Z",
          "updatedAt": "2020-08-24T22:40:58Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "(I wasn't sure what line you were referring to, so I'll merge now and can clean this up later!)",
              "createdAt": "2020-08-24T22:40:58Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MTE3MTAx",
          "commit": {
            "abbreviatedOid": "b378146"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T03:55:48Z",
          "updatedAt": "2020-08-25T03:55:49Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "My bad. I read HMQV instead of HKDF (too many H's :-)",
              "createdAt": "2020-08-25T03:55:49Z",
              "updatedAt": "2020-08-25T03:55:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 47,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcyODI5NjIy",
      "title": "Adopt the TLS 1.3 key schedule for better separation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/47",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-24T23:00:22Z",
      "updatedAt": "2020-08-26T12:26:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "63a8acabd6e6420146cb38a0cd8f238688839107",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/key-schedule",
      "headRefOid": "335f4e66c75d6523d85fb16811f0753dd42f4ec5",
      "closedAt": "2020-08-26T12:26:35Z",
      "mergedAt": "2020-08-26T12:26:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "196753132f819990fa1c582995985fbe87ae6de7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MTIxMjMy",
          "commit": {
            "abbreviatedOid": "c9f73de"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "See the comments on the key derivation. We need to decide on these (annoying) details",
          "createdAt": "2020-08-25T04:10:03Z",
          "updatedAt": "2020-08-25T04:37:17Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "\"OPAQUE\" instead of \"tls13\" I guess (use upper case OPAQUE to distinguish from the opaque type.",
              "createdAt": "2020-08-25T04:10:03Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            },
            {
              "originalPosition": 25,
              "body": "What I call Ke2, Ke3  is the equivalent of the handshake write keys in TLS 1.3, and Km2, Km3 are the equivalent of Finished keys. What I call SK is a key from which traffic write keys are derived. \r\nSo the equivalent to TLS would be to use  Derive_Secret to output handshake_traffic_secret and application_traffic_secret and then define the write_key derivations as in Section 7.3 of TLS 1.3 and the Finished key derivation as in Section 4.4 and 4.4.4.\r\nIf you want to simplify and keep it the way you defined it now, note that Ke2 and Ke3 cannot use hash.length but would have a length that depends on the ciphersuite's AEAD.\r\n\r\n",
              "createdAt": "2020-08-25T04:34:43Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NDUyMDc4",
          "commit": {
            "abbreviatedOid": "c9f73de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T12:56:03Z",
          "updatedAt": "2020-08-25T12:56:04Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Copy-paste bug :) Will fix!",
              "createdAt": "2020-08-25T12:56:03Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NDc0NzYy",
          "commit": {
            "abbreviatedOid": "46c5d09"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T13:22:27Z",
          "updatedAt": "2020-08-25T13:22:28Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Ah! Thanks for clarifying. I split the schedule into two parts: one for handshake secrets (Ke2, Ke3, Km2, Km3) and output AKE secrets (SK). All handshake keys, including the encryption and Finished/MAC keys, are derived from the client/server handshake secrets. What do you think?",
              "createdAt": "2020-08-25T13:22:28Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTc3Nzg0",
          "commit": {
            "abbreviatedOid": "46c5d09"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:24:09Z",
          "updatedAt": "2020-08-25T22:24:09Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Here is a simplification\r\n\r\n  HKDF-Extract(salt=0, IKM) = main_secret\r\n      |\r\n      +--> Derive-Secret(., \"c hs secret\", info) = client_handshake_secret\r\n      |\r\n      +--> Derive-Secret(., \"s hs secret\", info) = server_handshake_secret\r\n      |\r\n      +--> Derive-Secret(., \"c sk secret\", info) = client_session_key\r\n      |\r\n      +--> Derive-Secret(., \"s sk secret\", info) = server_session_key\r\n      |\r\n      v\r\n\r\nAnd it can even be simplified further by deriving a single handshake_secret and single session_key and do the separation client/server in further derivation.\r\n\r\nIt really depends how close to TLS 1.3 you want to be.  For example, do we want to stop at the session_key derivation or also derive the \"write keys\" for the AEAD to protect subsequent traffic as TLS 1.3 does?  \r\n",
              "createdAt": "2020-08-25T22:24:09Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTg5NDI0",
          "commit": {
            "abbreviatedOid": "46c5d09"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:29:45Z",
          "updatedAt": "2020-08-25T22:29:45Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Btw, getting too close to TLS 1.3 in names (e.g. client_handshake_secret), we may need to add \"OPAQUE\" as a label. Or maybe this is only done when actually integrating with TLS. \r\n",
              "createdAt": "2020-08-25T22:29:45Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MDA5NzE5",
          "commit": {
            "abbreviatedOid": "4525e69"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:39:49Z",
          "updatedAt": "2020-08-25T22:39:49Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Yeah, I think it's fine to reuse the names here. I applied the simplification you suggested (compressed to a single handshake and session secret), and then derived all handshake secrets (MAC and enc keys) from the handshake_secret.",
              "createdAt": "2020-08-25T22:39:49Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MTEyODk0",
          "commit": {
            "abbreviatedOid": "5c0b90e"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Look good! One nit: Change labels \"client auth\" to \"client mac\" (same for server)",
          "createdAt": "2020-08-26T02:46:09Z",
          "updatedAt": "2020-08-26T02:46:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc0OTk3NjI0",
      "title": "Fix the nonce length (Nn) to 32 bytes.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/48",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Making this a parameter seems like too much flexibility, so I suggest we be opinionated and remove it. ",
      "createdAt": "2020-08-27T23:11:34Z",
      "updatedAt": "2020-08-28T17:07:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "196753132f819990fa1c582995985fbe87ae6de7",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/fix-nonce",
      "headRefOid": "9fd53b3663bfb8bc871e3556ccd135df6a303242",
      "closedAt": "2020-08-28T17:07:59Z",
      "mergedAt": "2020-08-28T17:07:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a7d1e6cc3f87c7e4a1c4ed02aa633650191ea074"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> that in the future someone will want to steal a few bytes here and there from the nonce and then... :- )\r\n\r\nHah! :-)\r\n\r\n> Anyway, I would keep the Nn but I am ok if you feel strongly about getting rid of it.\r\n\r\nMy take is that an OPAQUE configuration can simply specify an OPRF, hash function (for HMAC and HKDF), and MHF, without any additional parameters. \r\n\r\nHow about I merge this with a note saying we could make this a parameter if flexibility is desired, and then as the larger group for feedback?",
          "createdAt": "2020-08-28T00:00:30Z",
          "updatedAt": "2020-08-28T00:00:30Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine with the 32 bytes. There is enough room to steal from it if needed. I can see it as more probable that someone will want to save in EnvU size than that 32 bytes will not be enough.\r\nBtw, you also need an AKE to specify OPAQUE in addition to the components you mention. ",
          "createdAt": "2020-08-28T00:52:55Z",
          "updatedAt": "2020-08-28T00:52:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Btw, you also need an AKE to specify OPAQUE in addition to the components you mention.\r\n\r\nYep!",
          "createdAt": "2020-08-28T17:07:55Z",
          "updatedAt": "2020-08-28T17:07:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTU3Mjgy",
          "commit": {
            "abbreviatedOid": "e0622f3"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't feel strongly about this but I don't see why with all parameters that are there, we need to remove just this one. One can imagine, in a very hypothetical way, that in the future someone will want to steal a few bytes here and there from the nonce and then... :- )\r\nIt also works in the other direction, for example for the envelope nonces 32 bytes is quite overkill as all one needs is that it does not repeat for a number of uses that is upper bound by the number of times the user changes his password over the history of his account. A 64-bit nonce would probably ok a 128-bit for sure. \r\nAnyway, I would keep the Nn but I am ok if you feel strongly about getting rid of it.\r\nYour call, I approve it anyway.",
          "createdAt": "2020-08-27T23:54:35Z",
          "updatedAt": "2020-08-27T23:54:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc1NTM5MzQy",
      "title": "Add a hash function dependency",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/49",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "And use it to control the auth_key and exporter_key size(s). ",
      "createdAt": "2020-08-28T17:21:45Z",
      "updatedAt": "2020-08-30T16:20:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "a7d1e6cc3f87c7e4a1c4ed02aa633650191ea074",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hash",
      "headRefOid": "23077ece157fe3da3a8a59b93b5f55814d52a337",
      "closedAt": "2020-08-30T16:20:07Z",
      "mergedAt": "2020-08-30T16:20:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7065e8d74c16275d98131340d3d197ee17cdf4b5"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I agree that it's overkill. I'll mark this as an OPEN ISSUE to consider fixing in the OPRF draft. (There was no reason to use SHA-512, other than being conservative, I think.)",
          "createdAt": "2020-08-30T16:18:48Z",
          "updatedAt": "2020-08-30T16:18:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDk4MDA5",
          "commit": {
            "abbreviatedOid": "c238558"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I am ok with the changes. SHA-512 is overkill for most keys derived in the protocol (256 bits are more than enough) but I guess we inherit the 512 from the OPRF ciphersuites.  Was there a special reason to use SHA-512 with 256-bit curves (P256 and 25519)? \r\n",
          "createdAt": "2020-08-29T04:44:43Z",
          "updatedAt": "2020-08-29T04:44:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc1OTMyNTc3",
      "title": "Require that the envelope export_key HMAC is checked before using the key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/50",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #30.",
      "createdAt": "2020-08-30T16:25:31Z",
      "updatedAt": "2020-08-31T14:25:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "7065e8d74c16275d98131340d3d197ee17cdf4b5",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/export-key-check",
      "headRefOid": "3914250e1bead6a4deef2f124b1ee8e0268d42c0",
      "closedAt": "2020-08-31T14:25:21Z",
      "mergedAt": "2020-08-31T14:25:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "48ad199022ca5fdaa6e99a45a08c4adc4a3b7cb8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MzAzNTU1",
          "commit": {
            "abbreviatedOid": "3914250"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-31T04:46:39Z",
          "updatedAt": "2020-08-31T04:46:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc4Mjg0Njc4",
      "title": "Restructure the document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/52",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This shuffles text around and fixes some lingering issues. I'll do a full pass over the text after we merge this (or some variant of it)!",
      "createdAt": "2020-09-03T01:35:51Z",
      "updatedAt": "2020-09-05T00:15:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "48ad199022ca5fdaa6e99a45a08c4adc4a3b7cb8",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/restructure",
      "headRefOid": "ef79a5b6b1cfe7d0e2d5d0bd3239d7d1f19cb25c",
      "closedAt": "2020-09-05T00:15:22Z",
      "mergedAt": "2020-09-05T00:15:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e1ff2f58342b48bb881538e3f80fa77e9af85096"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Chris, how do I edit the text in the pull request? This includes edits to\nparts you changed and also to text that existed before.\n\nOn Wed, Sep 2, 2020 at 9:36 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> @chris-wood <https://github.com/chris-wood> requested your review on: #52\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/52> Restructure the\n> document.\n>\n> \u2014\n> You are receiving this because your review was requested.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/52#event-3722484022>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXXZ7SDU72CEZFQ2NDDSD3XIJANCNFSM4QUC3XTQ>\n> .\n>\n",
          "createdAt": "2020-09-04T19:54:46Z",
          "updatedAt": "2020-09-04T19:54:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMDA1NzQz",
          "commit": {
            "abbreviatedOid": "ef79a5b"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Ready for last round before 00!",
          "createdAt": "2020-09-04T23:20:17Z",
          "updatedAt": "2020-09-04T23:20:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg3OTc5MzUz",
      "title": "Address Eric Crockett's review comments.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/56",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @crockeea",
      "createdAt": "2020-09-16T13:12:00Z",
      "updatedAt": "2020-09-22T01:56:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "eb5855c74d8068fdcd6267bc8beeb7865e8132b8",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/eric-review",
      "headRefOid": "7e61839c338a8224d277b985c79d909a7ffff813",
      "closedAt": "2020-09-22T01:56:40Z",
      "mergedAt": "2020-09-22T01:56:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "33e5132a3e7d20f0ef33cb4a1682a3eb490e9540"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw this PR should be good to go!",
          "createdAt": "2020-09-18T12:59:46Z",
          "updatedAt": "2020-09-18T12:59:46Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am afraid that I did not pushed  my comments (which I wrote them a couple of days ago) before for you to see.  Sorry for that. Eric also asked for a couple of clarifications to add (on the need of forward secrecy and something else). If you need text from me let me know.",
          "createdAt": "2020-09-19T00:57:30Z",
          "updatedAt": "2020-09-19T00:57:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw Thanks for the feedback -- I incorporated your comments. I also added some additional changes on top. Namely:\r\n\r\n- Fix the auth_tag size to the output of HMAC. (One less variable-length thing to worry about.)\r\n- Change how the auth_tag is computed. Previously, it did not include the length of the ciphertext or auth_data, which was worrisome. Now it's computed over the structure:\r\n\r\n```\r\nstruct {\r\n  opaque nonce[32];\r\n  opaque ct<1..2^16-1>;\r\n  opaque auth_data<0..2^16-1>;\r\n} InnerEnvelope;\r\n```\r\n\r\nwhich includes the length of `ct` and `auth_data`.\r\n\r\nPlease let me know what you think!",
          "createdAt": "2020-09-19T12:25:59Z",
          "updatedAt": "2020-09-19T12:25:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw, friendly bump! Please feel free to edit the PR directly if that's easier for you. :-)",
          "createdAt": "2020-09-21T23:51:53Z",
          "updatedAt": "2020-09-21T23:51:53Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the delay in responding to the latest changes. I was busy welcoming my second grandson... :-)",
          "createdAt": "2020-09-22T00:45:50Z",
          "updatedAt": "2020-09-22T00:45:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5ODU2OTM5",
          "commit": {
            "abbreviatedOid": "7d6ffa3"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-16T17:46:27Z",
          "updatedAt": "2020-09-19T00:54:26Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "You say AKE is out-of-scope but then we define several instantiations. I'm confused.",
              "createdAt": "2020-09-16T17:46:27Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 82,
              "body": "Shouldn't this (keygen for OPRF) be part of the above specification of the elements related to OPRF?",
              "createdAt": "2020-09-16T18:00:03Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 264,
              "body": "Simplify this sentence as:\r\nApplications may optionally include pkU, idU, or IdS in the Credentials.cleartext_credentials structure, or in envelopeCredentials.secret if secrecy of these values is desired. ",
              "createdAt": "2020-09-16T18:16:24Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 264,
              "body": "There is a sentence following this paragraph about server identity but the identity issues are discussed elsewhere A\r\n\r\nAlso: IdS uses capital I (also in other instances). It seems you skipped IdS in the global change to idS.",
              "createdAt": "2020-09-16T18:20:28Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 305,
              "body": "change 'authenticate stage' to \"authenticated key exchange stage\"",
              "createdAt": "2020-09-16T18:23:03Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 401,
              "body": "It is not clear what it means that \"applications must authenticate pkS\". This value is authenticated by the HMAC computation on the whole envelope so I don't think we need to single out this authentication as a separate/additional step.  Did you mean something different with this sentence?\r\n\r\nThe following text:\r\n\"If an application requires secrecy of pkS, this value SHOULD be omitted from auth_data (step 9).\"\r\nseems to belong to registration where the envelope is created not here.\r\nIf needed, let me know why (btw, the auth_data is now step 10)",
              "createdAt": "2020-09-16T18:32:06Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 438,
              "body": "I would not include this sentence about KCI here as it may be distracting. \r\nIf you think it should be there, I would say\r\nThis section describes several instantiations of OPAQUE using different AKE protocols (all of which satisfy the forward secrecy and KCI properties discussed in {{security-considerations}}).",
              "createdAt": "2020-09-16T18:36:41Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 472,
              "body": "It needs to be KCI resistant and also forward secure. Also, PQ AKE is not enough to PQ-protect data, also the data encryption scheme needs to be PQ secure.",
              "createdAt": "2020-09-16T18:41:23Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 792,
              "body": "Two comments on other parts of the specification:\r\n- Please add Greg Rubin to the list of Acknowledgments \r\n- I would change the following sentence:\r\nNote that this does not prevent a malicious server from conducting a dictionary attack on inputs provided by the client. OPAQUE assumes the server is honest, and only guarantees safeguards against parties who may later compromise the server and any stored user account information.\r\ninto:\r\nNote that a corrupted server can run an exhaustive offline dictionary attack to validate guesses for the user's password; this is inevitable in any aPAKE protocol. (OPAQUE enables a defense against such offline dictionary attacks by distributing the server so that an offline attack is only possible if all - or a minimal number of - servers are compromised.)\r\n",
              "createdAt": "2020-09-16T19:04:52Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTkzOTM0",
          "commit": {
            "abbreviatedOid": "a64bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T11:52:58Z",
          "updatedAt": "2020-09-19T11:52:58Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "It's currently not part of the OPRF API, so I left it off the list above. If the OPRF draft changes, we can change this too.",
              "createdAt": "2020-09-19T11:52:58Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTkzOTYz",
          "commit": {
            "abbreviatedOid": "a64bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T11:53:37Z",
          "updatedAt": "2020-09-19T11:53:38Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "What I meant is that this document doesn't intend to specify, describe, etc *new* AKEs, but I see how this is confusing. I'll just remove it.",
              "createdAt": "2020-09-19T11:53:37Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTk0MDE4",
          "commit": {
            "abbreviatedOid": "a64bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T11:54:51Z",
          "updatedAt": "2020-09-19T11:54:51Z",
          "comments": [
            {
              "originalPosition": 401,
              "body": "I think this entire paragraph is probably obsolete. I'll just remove it.",
              "createdAt": "2020-09-19T11:54:51Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTk0MDYw",
          "commit": {
            "abbreviatedOid": "a64bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T11:55:34Z",
          "updatedAt": "2020-09-19T11:55:35Z",
          "comments": [
            {
              "originalPosition": 438,
              "body": "That's a nice rewrite -- I'll take it!",
              "createdAt": "2020-09-19T11:55:34Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTk1NDM2",
          "commit": {
            "abbreviatedOid": "adb6579"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T12:23:49Z",
          "updatedAt": "2020-09-19T12:23:49Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "Fixed!",
              "createdAt": "2020-09-19T12:23:49Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTk1NDQ0",
          "commit": {
            "abbreviatedOid": "adb6579"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T12:23:54Z",
          "updatedAt": "2020-09-19T12:23:54Z",
          "comments": [
            {
              "originalPosition": 305,
              "body": "Fixed!",
              "createdAt": "2020-09-19T12:23:54Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDY5MDU3",
          "commit": {
            "abbreviatedOid": "adb6579"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T00:44:07Z",
          "updatedAt": "2020-09-22T00:44:08Z",
          "comments": [
            {
              "originalPosition": 874,
              "body": "Add a reference to the OPAQUE paper at the end of the parentheses",
              "createdAt": "2020-09-22T00:44:07Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDY5MTE2",
          "commit": {
            "abbreviatedOid": "adb6579"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T00:44:21Z",
          "updatedAt": "2020-09-22T00:44:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4MzAxNTY3",
      "title": "Clarify that keys must be unique per account.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/57",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We can address private key possession proofs and WebAuthn in a future change!",
      "createdAt": "2020-09-16T23:36:25Z",
      "updatedAt": "2020-09-18T12:40:32Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e1ff2f58342b48bb881538e3f80fa77e9af85096",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/key-reuse",
      "headRefOid": "baf190fd07fbe640d60dd0cbf99ef7e0d6ad7ee0",
      "closedAt": "2020-09-18T12:40:32Z",
      "mergedAt": "2020-09-18T12:40:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "eb5855c74d8068fdcd6267bc8beeb7865e8132b8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxMTE3ODMx",
          "commit": {
            "abbreviatedOid": "baf190f"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T03:02:01Z",
          "updatedAt": "2020-09-18T03:02:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkzNzk2NDI5",
      "title": "Update draft-irtf-cfrg-opaque.md",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/61",
      "state": "MERGED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I made some minir edits, nothing worth highlighting I think.\r\nTwo issues that we may want to address before submitting are:\r\n\r\n1. We say IBM has a patent on HMQV. Is that enough (for now at least) or do we need to have some formal IP notice?\r\n\r\n2. Section 6.3 (called from section 3.2 and 4.2.1) refers to SP800-56A Sec 5.6.2.3.4 which seems to be phrased for ephemeral keys while in the context of Sec 3.2 we talk about static ones. More importantly, the NIST document omits any tests of membership as they assume/require cofactor clearing. Is this something we want to assume/require ourselves? I thought we would \"outsource\" these issues to documents describing the curves themselves as the choice between explicit membership tests, prime order tests, cofactor operations, etc. may depend on the specific curve. If you do not want to get into these issues now (I am happy not to), we should still mention membership tests in Section 6.3. \r\n\r\nOnce we are done with these two issues, we can submit.\r\n",
      "createdAt": "2020-09-27T23:32:55Z",
      "updatedAt": "2020-09-28T18:33:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "13b1c0dcf6489faf7ca72b102358eda7168bee31",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "hugokraw-patch-1",
      "headRefOid": "e3e25988db565e6c8d2eeb16fad92ca0e165d94c",
      "closedAt": "2020-09-28T18:33:11Z",
      "mergedAt": "2020-09-28T18:33:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3c9462c70a3f2966d0b2ab3cfd8dafc805fae563"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> We say IBM has a patent on HMQV. Is that enough (for now at least) or do we need to have some formal IP notice?\r\n\r\nI think you can submit IPR here: https://datatracker.ietf.org/ipr/\r\n\r\n> If you do not want to get into these issues now (I am happy not to), we should still mention membership tests in Section 6.3.\r\n\r\nI think this is covered by \"MUST validate the other party's public key(s) used for the execution of OPAQUE\", no? If not, what would you change?",
          "createdAt": "2020-09-28T14:31:58Z",
          "updatedAt": "2020-09-28T14:31:58Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding:\r\n\r\n> >If you do not want to get into these issues now (I am happy not to), we should still mention membership tests in Section 6.3.\r\n\r\n> I think this is covered by \"MUST validate the other party's public key(s) used for the execution of OPAQUE\", no? If not, what would you change?\r\n\r\nThe problem is that we refer to the NIST document that does not include membership tests as they assume cofactor clearing which we don't assume. \r\nNote that we say explicitly:\r\n\r\nepkU, epkS are Diffie-Hellman ephemeral public keys chosen by user and server, respectively, which MUST be validated to be in the correct group (see {{validation}});\r\n\r\nbut then the membership test is lost in the reference to NIST.\r\n",
          "createdAt": "2020-09-28T16:55:28Z",
          "updatedAt": "2020-09-28T16:55:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The NIST document pertains only to the NIST curves, which don't require cofactor clearing (h=1). The other curves may involve cofactor clearing, but I think that's covered by the public key validation text. ",
          "createdAt": "2020-09-28T17:24:15Z",
          "updatedAt": "2020-09-28T17:24:15Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh. Ok. I missed the (clear) point that this is an example that only pertains to the NIST curves. Sorry for the confusion. You can go ahead and submit. Thanks.",
          "createdAt": "2020-09-28T18:25:38Z",
          "updatedAt": "2020-09-28T18:25:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Perfect -- thanks!",
          "createdAt": "2020-09-28T18:33:08Z",
          "updatedAt": "2020-09-28T18:33:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk3NTQ0MTQ2",
      "title": "Fixing typo in CredentialExtension definition and updating affiliation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/64",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I believe the type of the parameter `data` in `CredentialExtension` should be `opaque`, since there is no `CredentialData` defined anywhere.\r\n\r\nAlso updating my affiliation",
      "createdAt": "2020-10-05T02:21:20Z",
      "updatedAt": "2020-12-16T09:54:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "3c9462c70a3f2966d0b2ab3cfd8dafc805fae563",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_typo_1",
      "headRefOid": "405d25a53e81a3a3e51207f543712330b37969e3",
      "closedAt": "2020-10-19T18:29:41Z",
      "mergedAt": "2020-10-19T18:29:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "225bc77bec4a91c86519858ac20671fc6cd82aab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDQ2NzE1",
          "commit": {
            "abbreviatedOid": "405d25a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-19T18:29:35Z",
          "updatedAt": "2020-10-19T18:29:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2MjE2MTYw",
      "title": "Changing envelope representation in CredentialResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/66",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #62 ",
      "createdAt": "2020-10-19T19:07:37Z",
      "updatedAt": "2020-12-16T09:54:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "225bc77bec4a91c86519858ac20671fc6cd82aab",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_issue_62",
      "headRefOid": "05d229212a21eb826abe1c9c7e29bff26d86b52b",
      "closedAt": "2020-10-20T00:47:33Z",
      "mergedAt": "2020-10-20T00:47:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "550c550ecdc86ce362d613afebad67ce186cae73"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjU0OTc4",
          "commit": {
            "abbreviatedOid": "05d2292"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T00:47:29Z",
          "updatedAt": "2020-10-20T00:47:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3ODgyNjY4",
      "title": "Add a preliminary Sage implementation with many TODOs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/70",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This gets us started towards test vectors, with something that's \"as close\" to the specification as possible. There's definitely lots of ways this can be improved, including adding proper configuration and agility support, supporting different credentials in client and server, implementing a proper password file, etc. If this generally seems useful, we can add these missing pieces and then wrap it with code that generates test vectors from a variety of flows. \r\n\r\nNote that this *does not* have AKE integration. It only implements the OPAQUE core protocol. For the specification, I wonder if it makes sense to include test vectors for both the core protocol and AKE instantiations. \r\n\r\n@kevinlewi, please have a look!",
      "createdAt": "2020-10-21T21:47:26Z",
      "updatedAt": "2020-10-28T01:21:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "550c550ecdc86ce362d613afebad67ce186cae73",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/ref-impl",
      "headRefOid": "dbfb4c2d52519f01ed14fc440e28858c9a9485c8",
      "closedAt": "2020-10-28T01:21:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now -- I'll re-open when the 3DH implementation is in place.",
          "createdAt": "2020-10-28T01:21:43Z",
          "updatedAt": "2020-10-28T01:21:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 71,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3OTU3MDY4",
      "title": "Remove pkS from CredentialResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/71",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #63 ",
      "createdAt": "2020-10-22T01:42:06Z",
      "updatedAt": "2020-12-16T09:54:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "550c550ecdc86ce362d613afebad67ce186cae73",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_issue_63",
      "headRefOid": "dddf8300098fcd9aa71c4c54b0fa5e801008553d",
      "closedAt": "2020-10-23T21:04:20Z",
      "mergedAt": "2020-10-23T21:04:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "630173e46eaff00862dbb8446aa8a3c0b0bed8d1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDA5NTEz",
          "commit": {
            "abbreviatedOid": "dddf830"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T21:04:16Z",
          "updatedAt": "2020-10-23T21:04:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3OTcxMjYz",
      "title": "Omitting idU from RegistrationRequest and CredentialRequest",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/73",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This removes the inclusion of idU from RegistrationRequest and CredentialRequest (see #65)\r\n\r\nI also noticed that the functions `RecoverCredentials` and `FinalizeRequest` should either not take idU, or should take idU, idS, and pkU as parameters. In this PR I simply made RecoverCredentials also take idU as a parameter, but I opened #72 to discuss this further.",
      "createdAt": "2020-10-22T02:33:22Z",
      "updatedAt": "2020-12-16T09:54:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "630173e46eaff00862dbb8446aa8a3c0b0bed8d1",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_issue_65",
      "headRefOid": "7b76e78abfaa2a6a5f37f2b83438928d774b9412",
      "closedAt": "2020-10-27T22:59:30Z",
      "mergedAt": "2020-10-27T22:59:29Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b775d13311dcc73bbf9eefad1b00453c9ba1bb2f"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood : This should be ready to review",
          "createdAt": "2020-10-27T03:27:32Z",
          "updatedAt": "2020-10-27T03:27:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjEyMzE1",
          "commit": {
            "abbreviatedOid": "7b76e78"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-27T22:59:25Z",
          "updatedAt": "2020-10-27T22:59:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0NTExNTMzNjQ5",
      "title": "Remove the performance considerations section.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/76",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #5.\r\n\r\nIt was somewhat stale, and I'm not sure it adds much to the document.\r\n\r\ncc @kevinlewi ",
      "createdAt": "2020-10-28T13:08:34Z",
      "updatedAt": "2020-11-02T22:18:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "30a4a795bf17e7352a4c197d621dd4ede1db8101",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/remove-perf-section",
      "headRefOid": "85366a81b2bcfe89beb2c4b6dd8c874146538602",
      "closedAt": "2020-11-02T22:18:22Z",
      "mergedAt": "2020-11-02T22:18:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a41ef961ea49207c1ad256b1457631b673e5d198"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": " This is fine by me",
          "createdAt": "2020-10-28T19:13:20Z",
          "updatedAt": "2020-10-28T19:13:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE0MzkxOTE1",
      "title": "Swap labels, and adopt new OPRF suites.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/78",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @kevinlewi, I'll target submission today!",
      "createdAt": "2020-11-02T23:28:48Z",
      "updatedAt": "2020-11-02T23:35:46Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "a41ef961ea49207c1ad256b1457631b673e5d198",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/align-with-oprf",
      "headRefOid": "88c7e056eb21ae40766714d5add629e8c55ba81d",
      "closedAt": "2020-11-02T23:35:46Z",
      "mergedAt": "2020-11-02T23:35:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "25c0a16c4983d50ae4a75b415651034092ada78b"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Great!",
          "createdAt": "2020-11-02T23:34:33Z",
          "updatedAt": "2020-11-02T23:34:33Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 80,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE3NDU2Mzk3",
      "title": "Clarify base mode variant usage of voprf",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/80",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #79 ",
      "createdAt": "2020-11-09T04:22:23Z",
      "updatedAt": "2020-12-16T09:54:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "25c0a16c4983d50ae4a75b415651034092ada78b",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "clarify_base_mode_voprf",
      "headRefOid": "76c1112254a38e287019dc7d5ed14d8c1c96bbb8",
      "closedAt": "2020-11-09T16:31:46Z",
      "mergedAt": "2020-11-09T16:31:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "dd8581b6ac1d884673c017bd3666c6783f70baee"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NDMzNjMy",
          "commit": {
            "abbreviatedOid": "76c1112"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-09T16:31:35Z",
          "updatedAt": "2020-11-09T16:31:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE4ODI2NjI0",
      "title": "Defining idU and idS in AKE section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/81",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Points mentioned after discussion from #74 \r\n\r\n- Removes the sending of idU in KE1\r\n- Adds clarification text around what idU and idS refers to in the AKE key derivation. By default, they will be taken from the idU and idS specified in the envelope. If they are not specified, then they are taken to be equal to pkU and pkS.\r\n- Also clarify that if pkU is not in the envelope, then it must be computed from skU.",
      "createdAt": "2020-11-10T23:32:21Z",
      "updatedAt": "2020-12-16T09:54:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "dd8581b6ac1d884673c017bd3666c6783f70baee",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "ake_ids",
      "headRefOid": "73e04f431366c4f5275d5ff7fd311976be41d0de",
      "closedAt": "2020-11-12T23:32:13Z",
      "mergedAt": "2020-11-12T23:32:13Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "deeeead3207280710202773f68edb85c8171704b"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am ok with these changes, they reflect the conclusions of our discussion. \r\nI have a feeling that people will wonder about why are pkU, pkS set as default identities and in what cases they should or should not set different values for idU and idS.  Answering these question would require iterating some of the issues discussed in our thread (why identities are needed at all, what's their roles, etc.). Do you think there is some text you could write to explain some of these things and preempt some of the confusion? I would not dare to write such text myself :-)",
          "createdAt": "2020-11-11T04:11:33Z",
          "updatedAt": "2020-11-11T04:11:33Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am ok with these changes, they reflect the conclusions of our discussion.\r\n> I have a feeling that people will wonder about why are pkU, pkS set as default identities and in what cases they should or should not set different values for idU and idS. Answering these question would require iterating some of the issues discussed in our thread (why identities are needed at all, what's their roles, etc.). Do you think there is some text you could write to explain some of these things and preempt some of the confusion? I would not dare to write such text myself :-)\r\n\r\n@hugokraw Please take a look at the text that I have added to the \"Security Considerations\" section, also copied below:\r\n\r\n```\r\n## User and server identities\r\n\r\nThe user identity (idU) and server identity (idS) are optional parameters\r\nwhich are left to the application to designate as monikers for the client\r\nand server. If the application layer does not supply values for these\r\nparameters, then they will be omitted from the creation of the envelope\r\nduring the registration stage. Furthermore, they will be substituted with\r\nidU = pkU and idS = pkS during the authenticated key exchange stage.\r\n\r\nThe advantage to supplying a custom idU and idS (instead of simply relying\r\non a fallback to pkU and pkS) is that the client can then ensure that any\r\nmappings between idU and pkU (and idS and pkS) are protected by the\r\nauthentication from the envelope. Then, the client can attempt to verify\r\nthat the idU and idS contained in its envelope matches the idU and idS\r\nsupplied by the server.\r\n\r\nHowever, if this extra layer of verification is unnecessary for the\r\napplication, then simply leaving idU and idS unspecified is acceptable.\r\n```\r\n---\r\n\r\nLet me know if you think we should edit this.",
          "createdAt": "2020-11-12T22:17:38Z",
          "updatedAt": "2020-11-12T22:17:38Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I like it. Two edits:\r\n- remove \"attempt to\"\r\n- edit last sentence to: then simply leaving idU and idS unspecified, and using pkU and pkS instead, is acceptable.",
          "createdAt": "2020-11-12T22:58:28Z",
          "updatedAt": "2020-11-12T22:58:28Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Done. Thanks!",
          "createdAt": "2020-11-12T23:13:24Z",
          "updatedAt": "2020-11-12T23:13:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjkzNDc3",
          "commit": {
            "abbreviatedOid": "65b3353"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This matches my understanding. @hugokraw, can you please have a look?",
          "createdAt": "2020-11-10T23:36:27Z",
          "updatedAt": "2020-11-10T23:36:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 86,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIxOTI3NTQ5",
      "title": "Remove protocol messages.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/86",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #85. \r\n\r\ncc @kevinlewi, @stef",
      "createdAt": "2020-11-16T20:21:12Z",
      "updatedAt": "2020-11-16T20:31:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "deeeead3207280710202773f68edb85c8171704b",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/remove-protocol-messages",
      "headRefOid": "dc89d10a1c38b16fba682c0c61a0b7f31203a4a6",
      "closedAt": "2020-11-16T20:31:56Z",
      "mergedAt": "2020-11-16T20:31:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0e1da280c97f4402d4f2fd56d4ef4451b9d46ac1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNzIxMDg5",
          "commit": {
            "abbreviatedOid": "a274e8e"
          },
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T20:29:37Z",
          "updatedAt": "2020-11-16T20:30:08Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Perhaps we want to keep this sentence:\r\n\r\n> This section specifies the structure of these protocol\r\nmessages using TLS notation (see {{RFC8446}}, Section 3).\r\n\r\nSince it still applies for the remainder of the document",
              "createdAt": "2020-11-16T20:29:37Z",
              "updatedAt": "2020-11-16T20:31:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 92,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI4Nzg1NjQ5",
      "title": "Update to some minor details of the current VOPRF draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/92",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "cc./ @chris-wood ",
      "createdAt": "2020-11-27T20:56:26Z",
      "updatedAt": "2020-12-01T15:40:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "0e1da280c97f4402d4f2fd56d4ef4451b9d46ac1",
      "headRepository": "claucece/draft-irtf-cfrg-opaque",
      "headRefName": "master",
      "headRefOid": "19de398f26ef20e44ac7dceb1bb165b9c2013043",
      "closedAt": "2020-12-01T15:40:33Z",
      "mergedAt": "2020-12-01T15:40:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8894db3c031a56873bbd536f7fe3eaf4dc1e4ad6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwOTgyNDMy",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks! I've been meaning to get around to this. I think some things regressed, which I've noted. Otherwise, this is good.",
          "createdAt": "2020-11-30T14:52:49Z",
          "updatedAt": "2020-11-30T15:01:11Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Can we please revert this? `KeyGen` returns a public and private key pair. It just so happens that OPAQUE ignores the public key for per-user keys. \r\n\r\nAlternatively, we can change `KeyGen` notation in pseudocode below.",
              "createdAt": "2020-11-30T14:52:49Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            },
            {
              "originalPosition": 38,
              "body": "Why did we remove this clarifying text?",
              "createdAt": "2020-11-30T14:53:21Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            },
            {
              "originalPosition": 71,
              "body": "Perhaps we should use notation `SerializeScalar`?",
              "createdAt": "2020-11-30T14:55:39Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            },
            {
              "originalPosition": 149,
              "body": "Please revert this change.",
              "createdAt": "2020-11-30T14:59:12Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            },
            {
              "originalPosition": 262,
              "body": "This should be reverted. It's the server that looks up envU using idU.",
              "createdAt": "2020-11-30T14:59:52Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDMyNDg4",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:43:01Z",
          "updatedAt": "2020-11-30T15:43:02Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I'll revert it ;)",
              "createdAt": "2020-11-30T15:43:02Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDMzMDI1",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:43:37Z",
          "updatedAt": "2020-11-30T15:43:37Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The data returned from the OPRF functions is always already encoded/serialized, so no need to specify how to encode.",
              "createdAt": "2020-11-30T15:43:37Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDMzNDMy",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:44:04Z",
          "updatedAt": "2020-11-30T15:44:04Z",
          "comments": [
            {
              "originalPosition": 262,
              "body": "Ah, ok. Reverting this.",
              "createdAt": "2020-11-30T15:44:04Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDM0OTI3",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:45:36Z",
          "updatedAt": "2020-11-30T15:45:36Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Except for the scalar that is returned from `blind`.",
              "createdAt": "2020-11-30T15:45:36Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDM1ODI5",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:46:30Z",
          "updatedAt": "2020-11-30T15:46:30Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Agreed ;)",
              "createdAt": "2020-11-30T15:46:30Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDUwMjU2",
          "commit": {
            "abbreviatedOid": "40c68c9"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T16:00:49Z",
          "updatedAt": "2020-11-30T16:00:50Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "Done.",
              "createdAt": "2020-11-30T16:00:49Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTgxNzg4",
          "commit": {
            "abbreviatedOid": "40c68c9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-01T14:56:02Z",
          "updatedAt": "2020-12-01T14:56:03Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-12-01T14:56:03Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTgyMDQx",
          "commit": {
            "abbreviatedOid": "40c68c9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-01T14:56:17Z",
          "updatedAt": "2020-12-01T14:56:17Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-12-01T14:56:17Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTgyNTE2",
          "commit": {
            "abbreviatedOid": "19de398"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-01T14:56:42Z",
          "updatedAt": "2020-12-01T14:56:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 93,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMwMzYyMDYy",
      "title": "Move idU to CreateCredentialResponse parameter.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/93",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The OPAQUE wrapper protocol is responsible for transmitting idU from\r\nclient to server. OPAQUE does not use it for anything other than password\r\nfile lookup.\r\n\r\nCloses #88.\r\n\r\ncc @kevinlewi, @stef",
      "createdAt": "2020-12-01T14:55:31Z",
      "updatedAt": "2020-12-02T03:15:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "8894db3c031a56873bbd536f7fe3eaf4dc1e4ad6",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/move-idU-to-parameter",
      "headRefOid": "8d779da370c0ba14e5f35a4539a920a303fb5a8f",
      "closedAt": "2020-12-02T03:15:07Z",
      "mergedAt": "2020-12-02T03:15:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "455538b2043587ea9e455e4f64b111a012dacee7"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks good, but I do have a general comment that maybe we can move to discussion in an issue:\r\n\r\nWould it make more sense to perhaps make kU, envU, pkU parameters to CreateCredentialResponse? The reason is because \"LookupUserRecord\" is not actually defined anywhere, and is only run in the wrapper protocol, so it may cause confusion.\r\n\r\n",
          "createdAt": "2020-12-02T02:14:32Z",
          "updatedAt": "2020-12-02T02:14:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Would it make more sense to perhaps make kU, envU, pkU parameters to CreateCredentialResponse? The reason is because \"LookupUserRecord\" is not actually defined anywhere, and is only run in the wrapper protocol, so it may cause confusion.\r\n\r\nYeah, I like that suggestion. Stand by while I make the change!",
          "createdAt": "2020-12-02T02:23:00Z",
          "updatedAt": "2020-12-02T02:23:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi fixed!",
          "createdAt": "2020-12-02T02:25:54Z",
          "updatedAt": "2020-12-02T02:25:54Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Cool, looks! Minor nit: Shouldn't kU, envU, pkU be listed in the Input, not the Parameters (and also following an update to read as: \"CreateCredentialResponse(request)\" -> \"CreateCredentialResponse(request, kU, envU, pkU))",
          "createdAt": "2020-12-02T02:27:03Z",
          "updatedAt": "2020-12-02T02:27:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I opted to keep them as parameters since they're handled by the wrapper protocol and provided by context. Would it be more clear if they were inputs?",
          "createdAt": "2020-12-02T02:58:41Z",
          "updatedAt": "2020-12-02T02:58:41Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can leave it to a separate change since it is probably a separate discussion, but I also noted that for \"CreateRegistrationResponse\", pkS is an input instead of a parameter. Not sure if that should change, but it seems like they should both be parameters or both be inputs.\r\n\r\nAnyway, not a big deal either way, at least for now!",
          "createdAt": "2020-12-02T03:01:29Z",
          "updatedAt": "2020-12-02T03:01:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch -- moved to inputs!",
          "createdAt": "2020-12-02T03:08:23Z",
          "updatedAt": "2020-12-02T03:08:23Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Excellent",
          "createdAt": "2020-12-02T03:14:39Z",
          "updatedAt": "2020-12-02T03:14:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 95,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMxNDM3MjM4",
      "title": "Remove wrapper RequestMetadata type.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/95",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #94.\r\n\r\ncc @kevinlewi ",
      "createdAt": "2020-12-03T03:55:58Z",
      "updatedAt": "2020-12-03T04:14:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "455538b2043587ea9e455e4f64b111a012dacee7",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/remove-metadata-wrapper",
      "headRefOid": "fe4625c9650c5added4c1b4ea1105707886a6c7b",
      "closedAt": "2020-12-03T04:14:20Z",
      "mergedAt": "2020-12-03T04:14:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c4246341b42614facba070e74733cd6391a6bc80"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI0OTA0",
          "commit": {
            "abbreviatedOid": "ab207c2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T03:58:22Z",
          "updatedAt": "2020-12-03T03:58:23Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "\"a RequestMetadata structure\" should be replaced with \"an OPRF Scalar value\"",
              "createdAt": "2020-12-03T03:58:23Z",
              "updatedAt": "2020-12-03T04:07:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI1Mzk1",
          "commit": {
            "abbreviatedOid": "ab207c2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T03:59:48Z",
          "updatedAt": "2020-12-03T03:59:48Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Where is SerializedElement defined? Perhaps a reference to an RFC #?",
              "createdAt": "2020-12-03T03:59:48Z",
              "updatedAt": "2020-12-03T04:07:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI3NDEw",
          "commit": {
            "abbreviatedOid": "ab207c2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T04:06:07Z",
          "updatedAt": "2020-12-03T04:06:07Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "Missed this one -- thanks!",
              "createdAt": "2020-12-03T04:06:07Z",
              "updatedAt": "2020-12-03T04:07:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI3ODIy",
          "commit": {
            "abbreviatedOid": "fe4625c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T04:07:25Z",
          "updatedAt": "2020-12-03T04:07:26Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I clarified that this is an alias for a serialized group element, i.e., output of `Serialize()`.",
              "createdAt": "2020-12-03T04:07:26Z",
              "updatedAt": "2020-12-03T04:07:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI5Mzkz",
          "commit": {
            "abbreviatedOid": "fe4625c"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good!",
          "createdAt": "2020-12-03T04:12:18Z",
          "updatedAt": "2020-12-03T04:12:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 101,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQxNTUyNzM1",
      "title": "Reference \"Partitioning Oracle Attacks\" paper.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/101",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #100.\r\n\r\ncc @hugokraw, @stef",
      "createdAt": "2020-12-17T02:10:12Z",
      "updatedAt": "2020-12-21T16:42:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "c4246341b42614facba070e74733cd6391a6bc80",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/ref-partition-oracles",
      "headRefOid": "baa0242e64db498dbdea171d3de227a39cdf9486",
      "closedAt": "2020-12-21T16:42:15Z",
      "mergedAt": "2020-12-21T16:42:15Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d7cb97511bbfa2a55c29b44600be11d0cb5ae3cc"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> In this case we would say that while the paper requires it, this specification does not (in particular, partition attacks as those described in the Julia et al paper are irrelevant to this specification).\r\n\r\nSo, to be clear, would you just drop the reference from this PR? If so, we lose a pointer to the RKR definition, which I was hoping to outsource to somewhere else. ",
          "createdAt": "2020-12-19T15:28:32Z",
          "updatedAt": "2020-12-19T15:28:32Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the following text in the security considerations addresses this issue.\r\n\r\nWe note that the analysis of OPAQUE from {{OPAQUE}} requires the authenticated encryption scheme used to produce envU to have a special property called random key-robustness (or key-committing). This specification enforces this property by utilizing encryption-then-hmac in the construction of envU. There is no option to use another authenticated-encryption scheme with this specification.  (Deviating from the key-robustness requirement may open the protocol to attacks, e.g., {{Len}}.) We remark that export_key for authentication and/or encryption requires no special properties from the authentication/encryption schemes as long as exporter_key is used only after the EnvU is validated (i.e., after the HMAC in RecoverCredentials passes verification).",
          "createdAt": "2020-12-20T22:09:31Z",
          "updatedAt": "2020-12-20T22:09:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That's much better. I'll update this PR with that suggestion and then close out this issue. ",
          "createdAt": "2020-12-21T16:34:27Z",
          "updatedAt": "2020-12-21T16:34:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzA4MTgx",
          "commit": {
            "abbreviatedOid": "03b08db"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Wait with this reference. Not sure if we need to touch on this point at all as there is no key robustness requirement for this specification. At most, it could be discussed in the security considerations just because the OPAQUE paper requires it. In this case we would say that while the paper requires it, this specification does not (in particular, partition attacks as those described in the Julia et al paper are irrelevant to this specification).  ",
          "createdAt": "2020-12-17T06:21:27Z",
          "updatedAt": "2020-12-17T06:21:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 102,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQyNDc4ODY3",
      "title": "Changing envelope definition to  support two fixed modes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/102",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #99.\r\n\r\nThis defines two modes, `base` and `customIdentifier` for the envelope. The credentials are incorporated in the `SecretCredentials` and `CleartextCredentials` structs,\r\ndepending on the mode set by the value of `EnvelopeMode`:\r\n\r\n```\r\nenum {\r\n  base(1),\r\n  customIdentifier(2),\r\n  (255)\r\n} EnvelopeMode;\r\n```\r\n\r\nThe `base` mode defines `SecretCredentials` and `CleartextCredentials` as follows:\r\n\r\n```\r\nstruct {\r\n  opaque skU<1..2^16-1>;\r\n} SecretCredentials;\r\n\r\nstruct {\r\n  opaque pkS<1..2^16-1>;\r\n} CleartextCredentials;\r\n```\r\n\r\nThe `customIdentifier` mode defines `SecretCredentials` and `CleartextCredentials` as follows:\r\n\r\n```\r\nstruct {\r\n  opaque skU<1..2^16-1>;\r\n} SecretCredentials;\r\n\r\nstruct {\r\n  opaque pkS<1..2^16-1>;\r\n  opaque idU<0..2^16-1>;\r\n  opaque idS<0..2^16-1>;\r\n} CleartextCredentials;\r\n```\r\n\r\nThese credentials are embedded into the following `Envelope` structure with\r\nencryption and authentication.\r\n\r\n```\r\nstruct {\r\n  InnerEnvelopeMode mode;\r\n  opaque nonce[32];\r\n  opaque ct<1..2^16-1>;\r\n} InnerEnvelope;\r\n\r\nstruct {\r\n  InnerEnvelope contents;\r\n  opaque auth_tag[Nh];\r\n} Envelope;\r\n```\r\n\r\nAlso updated the `FinalizeRequest` and `RecoverCredentials` procedures accordingly. Also updated the fixed string to read `OPAQUE01` instead of `OPAQUE00`.",
      "createdAt": "2020-12-18T11:16:37Z",
      "updatedAt": "2021-01-04T19:27:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "af3cd96b76fd8aaa1bf83f290f7714973ab8e64b",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "dual_mode_envelope",
      "headRefOid": "56a30f30e70f824e4ad9ad42497126c6103a14bd",
      "closedAt": "2021-01-04T19:27:56Z",
      "mergedAt": "2021-01-04T19:27:56Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0e39200d483f37d5b1be63a5fecc0b94017ccc96"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "* I added a note in the configurations section: \"The EnvelopeMode value is defined in {{data-types}} and must also be agreed upon between the client and server.\"\r\n* Thanks, good catch. Removed!\r\n* The expectation is that idS should come from the wrapper protocol. I think it is unnecessary to include idS in `RegistrationResponse`, regardless of the mode. Therefore, I think it is unnecessary to change anything here regarding this point. What do you think?",
          "createdAt": "2020-12-21T04:04:24Z",
          "updatedAt": "2020-12-21T04:04:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The expectation is that idS should come from the wrapper protocol. I think it is unnecessary to include idS in RegistrationResponse, regardless of the mode. Therefore, I think it is unnecessary to change anything here regarding this point. What do you think?\r\n\r\nI think that's fine, but I would make things more explicit. If the wrapper protocol provides them, then it might as well also supply them to the relevant procedures for constructing the envelope. Then we could replace this:\r\n\r\n\"Create cleartext_credentials with credentials matching those needed to construct the `CleartextCredentials` structure\"\r\n\r\nwith something like:\r\n\r\n\"Create `CleartextCredentials` structure cleartext_credentials where cleartext_credentials.idU = idU, cleartext_credentials.idS = idS, cleartext_credentials.pkS = pkS.\"",
          "createdAt": "2020-12-21T15:27:39Z",
          "updatedAt": "2020-12-21T15:27:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Following up on the comment above, we might simplify things by delegating the \"credential construction\" logic to the wrapper protocol, which (a) knows the mode and (b) has the relevant information (skU, idU, pkS, idS, etc). That would make the interface to `FinalizeRequest` something like so:\r\n\r\n```\r\nFinalizeRequest(pwdU, creds, blind, response)\r\n```\r\n\r\nWhere `creds` contains the `secret_credentials` and `cleartext_credentials`, already in wire format form, to use when creating the envelope. ",
          "createdAt": "2020-12-22T19:01:10Z",
          "updatedAt": "2020-12-22T19:01:10Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed comments, ready for a re-review",
          "createdAt": "2020-12-25T03:20:56Z",
          "updatedAt": "2020-12-25T03:20:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2MDI3MTA3",
          "commit": {
            "abbreviatedOid": "b627ad5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I like this :) I have a couple questions that I hope we can resolve moving forward:\r\n\r\n- The mode is currently implicit in registration and login. I assume the expectation is that configurations specify the mode so that it's known to both peers. We should probably say that somewhere. I left a suggestion to include this note, but we probably ought to expand upon it in the configuration section.\r\n- The `RegistrationResponse` definition still includes a list of secret and cleartext credential types. This can be removed given that these are dependent on the mode. \r\n- Credential construction is somewhat vague in the current description, especially since idU and idS are not passed as parameters to the main registration and login routines. As an implementor, is the expectation that idS comes from the client's wrapper protocol, or is it sent from server to client as part of the registration response? (My understanding is the latter.) Since there are only two modes, we might, for example, define two mode-specific `FinalizeRequest` variants, each of which takes the appropriate parameters. (The base mode variant includes what is currently there now, whereas the custom-mode variant might also include idU (and idS depending on the answer to the previous question).)\r\n\r\nObviously, we can work on these things incrementally and merge in pieces, but I wanted to flag these questions to start.",
          "createdAt": "2020-12-20T15:24:41Z",
          "updatedAt": "2020-12-20T15:44:19Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "```suggestion\r\ncovering `InnerEnvelope` and `CleartextCredentials`.\r\n```",
              "createdAt": "2020-12-20T15:24:42Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            },
            {
              "originalPosition": 278,
              "body": "```suggestion\r\nthen these values (independently) default to pkU and pkS instead.\r\n```",
              "createdAt": "2020-12-20T15:32:58Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            },
            {
              "originalPosition": 117,
              "body": "```suggestion\r\n`SecretCredentials` and `CleartextCredentials` is described in {{finalize-request}}.\r\n\r\nThe `EnvelopeMode` value is specified as part of a configuration. \r\n```",
              "createdAt": "2020-12-20T15:33:13Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NDYxNDAz",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-21T15:27:26Z",
          "updatedAt": "2020-12-21T15:27:27Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "This implies (to me) some sort of negotiation. Since the EnvelopeMode is already in the tuple above, I'd drop that bit:\r\n\r\n```suggestion\r\nThe EnvelopeMode value is defined in {{data-types}}.\r\n```",
              "createdAt": "2020-12-21T15:27:26Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MjgzNzUz",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-22T18:31:25Z",
          "updatedAt": "2020-12-22T18:31:26Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "Unrelated: should we lift `pkU` to the wrapper protocol, too? Specifically, perhaps `FinalizeRequest` should produce an envelope and export key, and the wrapper protocol is then responsible for sending the envelope and `pkU` to the server.",
              "createdAt": "2020-12-22T18:31:26Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Mjk4ODcw",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-22T18:59:13Z",
          "updatedAt": "2020-12-22T18:59:14Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Also unrelated, but we can remove `request` here, as it's not used.",
              "createdAt": "2020-12-22T18:59:13Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NzkzODUz",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "bytemare",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-23T10:53:23Z",
          "updatedAt": "2020-12-23T10:53:24Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "If SecretCredentials is always equal to the client secret, wouldn't it be more straightforward to put `pt = Serialize(secret)` ?",
              "createdAt": "2020-12-23T10:53:24Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Nzk1Mjg1",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "bytemare",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-23T10:56:19Z",
          "updatedAt": "2020-12-23T10:56:19Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "If I'm not mistaken, the InnerEnvelope should also specify the InnerEnvelopeMode, doesn't it?",
              "createdAt": "2020-12-23T10:56:19Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4MjI2NTU0",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-23T21:00:06Z",
          "updatedAt": "2020-12-23T21:00:06Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "It is used in line 468:\r\n\r\n```\r\nThe full procedure for constructing `Envelope` and `InnerEnvelope` from\r\n`SecretCredentials` and `CleartextCredentials` is described in {{finalize-request}}.\r\n```",
              "createdAt": "2020-12-23T21:00:06Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NzQzODc0",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-25T03:13:01Z",
          "updatedAt": "2020-12-25T03:13:01Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "As discussed offline, let's address this API change separately.",
              "createdAt": "2020-12-25T03:13:01Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NzQ0Mzc2",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-25T03:17:17Z",
          "updatedAt": "2020-12-25T03:17:18Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "I think it may be beneficial to keep this level of generality here in case we add support for other modes that set SecretCredentials to something else in the future. This will hopefully also coincide with the changes that will be made in #105 which will pass in a generic credentials parameter.",
              "createdAt": "2020-12-25T03:17:18Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NzQ0NjY0",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-25T03:19:54Z",
          "updatedAt": "2020-12-25T03:19:55Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Good catch, thank you! Added to parameters.",
              "createdAt": "2020-12-25T03:19:54Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMjgyNTYw",
          "commit": {
            "abbreviatedOid": "56a30f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-04T19:27:17Z",
          "updatedAt": "2021-01-04T19:27:17Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "I'll address this in a separate PR, since it seems related to the module boundary we discussed.",
              "createdAt": "2021-01-04T19:27:17Z",
              "updatedAt": "2021-01-04T19:27:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMjgyODg5",
          "commit": {
            "abbreviatedOid": "56a30f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-04T19:27:46Z",
          "updatedAt": "2021-01-04T19:27:46Z",
          "comments": []
        }
      ]
    }
  ]
}